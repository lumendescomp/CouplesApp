<div class="space-y-6">
  <header class="flex items-center justify-between">
    <h1 class="text-2xl font-semibold text-violet-100">Nosso cantinho</h1>
    <form
      id="add-item-form"
      hx-post="/corner/items"
      hx-target="#corner-outbox"
      hx-swap="innerHTML"
      class="flex items-center gap-2"
    >
      <select
        name="item_key"
        class="bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100"
      >
        <option value="table">Mesa</option>
        <option value="chair">Cadeira</option>
        <option value="plant">Planta</option>
        <option value="lamp">Luminária</option>
      </select>
      <button
        class="px-3 py-2 rounded bg-white/10 text-violet-100 hover:bg-white/20"
        type="submit"
      >
        Adicionar
      </button>
      <input type="hidden" name="_csrf" value="test" />
    </form>
  </header>

  <div class="grid grid-cols-[1fr_280px] gap-6">
    <!-- Canvas do cantinho -->
    <section
      class="relative rounded-xl border border-violet-700/40 bg-white/5 overflow-hidden min-h-[420px]"
    >
      <div id="corner-canvas" class="absolute inset-0"></div>
      <div id="corner-outbox" class="hidden" aria-hidden="true"></div>
    </section>

    <!-- Inventário -->
    <aside class="rounded-xl border border-violet-700/40 bg-white/5 p-3">
      <h2 class="text-lg text-violet-100 mb-3">Inventário</h2>
      <ul class="space-y-2 text-violet-200 text-sm">
        <li>Mesa</li>
        <li>Cadeira</li>
        <li>Planta</li>
        <li>Luminária</li>
      </ul>
      <p class="mt-4 text-xs text-violet-300/80">
        Arraste itens no canvas (versões futuras).
      </p>
    </aside>
  </div>
</div>

<!-- PixiJS -->
<script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
<script>
  // Dados iniciais vindos do servidor
  window.__cornerItems = [{"id":1,"item_key":"table","x":20,"y":40,"z":0,"rotation":0},{"id":2,"item_key":"plant","x":80,"y":70,"z":3,"rotation":0}];
  // Primeira etapa rumo ao "Habbo": grid isométrico 10x10 com projeção simples.
  const HS_ISO = {
    gridN: 10,
    tileW: 72,
    tileH: 36,
    // Converte (gx, gy) -> (sx, sy) em pixels, centralizando no canvas
    project(container, gx, gy) {
      const { tileW, tileH, gridN } = this;
      const cw = container.clientWidth || 800;
      const ch = container.clientHeight || 420;
      const gridPixelW = gridN * tileW; // aprox para centralização
      const gridPixelH = gridN * tileH; // aprox para centralização
      const x0 = cw / 2; // centro do canvas
      const y0 = Math.max(24, (ch - gridPixelH) / 2) + tileH; // um pouco abaixo do topo
      const sx = x0 + (gx - gy) * (tileW / 2);
      const sy = y0 + (gx + gy) * (tileH / 2);
      return { sx, sy };
    },
  };

  function renderIsoFloor() {
    const container = document.getElementById("corner-canvas");
    if (!container) return;
    let floor = container.querySelector("[data-iso-floor]");
    if (floor) floor.remove();
    floor = document.createElement("div");
    floor.setAttribute("data-iso-floor", "");
    floor.style.position = "absolute";
    floor.style.inset = "0";
    floor.style.zIndex = "0";
    floor.style.pointerEvents = "none";
    container.appendChild(floor);

    const { gridN, tileW, tileH } = HS_ISO;
    for (let i = 0; i < gridN; i++) {
      for (let j = 0; j < gridN; j++) {
        const { sx, sy } = HS_ISO.project(container, i, j);
        const tile = document.createElement("div");
        tile.className = "pointer-events-none";
        tile.style.position = "absolute";
        tile.style.left = sx + "px";
        tile.style.top = sy + "px";
        tile.style.width = tileW + "px";
        tile.style.height = tileH + "px";
        tile.style.transform =
          "translate(-50%, -50%) rotate(45deg) scaleY(0.5)";
        tile.style.border = "1px solid rgba(124,58,237,0.18)"; // violet-600/18
        tile.style.background =
          "linear-gradient(135deg, rgba(124,58,237,0.14), rgba(192,38,211,0.10))";
        tile.style.boxShadow =
          "inset 0 1px 0 rgba(255,255,255,0.06), 0 1px 4px rgba(0,0,0,0.12)";
        floor.appendChild(tile);
      }
    }
  }

  function positionCornerItems() {
    const container = document.getElementById("corner-canvas");
    if (!container) return;
    // desenha/atualiza chão (tiles)
    renderIsoFloor();
    // posiciona itens em coordenadas de grade (aproxima x/y% -> células 0..gridN) e aplica altura z
    document.querySelectorAll("#corner-canvas .corner-item").forEach((el) => {
      const xPct = Number(el.getAttribute("data-x") || 50);
      const yPct = Number(el.getAttribute("data-y") || 50);
      const z = Number(el.getAttribute("data-z") || 0);
      const rot = Number(el.getAttribute("data-rot") || 0);
      const gx = Math.max(
        0,
        Math.min(
          HS_ISO.gridN - 1,
          Math.round(xPct / (100 / (HS_ISO.gridN - 1)))
        )
          function positionCornerItems() {
      const gy = Math.max(
        0,
        Math.min(
          HS_ISO.gridN - 1,
            // Render Pixi
            ensurePixi();
    let dragging = null; // { el, id, z, gx, gy }

    container.querySelectorAll(".corner-item").forEach((el) => {
          document.addEventListener("htmx:afterSwap", (e) => {
            // Se swap ocorreu no outbox, provavelmente foi adição: parse o item e adicionar na cena
            const target = e && e.detail && e.detail.target;
            if (target && target.id === 'corner-outbox') {
              const node = target.querySelector('.corner-item');
              if (node) {
                const item = domItemToData(node);
                addOrUpdateItem(item);
                target.innerHTML = '';
              }
            }
            positionCornerItems();
          });
      el.addEventListener("pointerdown", (ev) => {
        if (ev.button !== 0) return; // apenas botão esquerdo
        // não iniciar drag ao clicar em controles/links/htmx
        if (
          ev.target.closest(
            "button, [hx-post], [hx-get], [hx-put], [hx-delete], form, a"
          // ===== Implementação Pixi =====
          let PIXI_APP = null;
          let SCENE = { items: new Map(), selectedId: null };

          function domItemToData(node){
            return {
              id: Number(node.getAttribute('data-id')),
              item_key: (node.querySelector('[class]') && 'unknown') || 'unknown',
              x: Number(node.getAttribute('data-x')||50),
              y: Number(node.getAttribute('data-y')||50),
              z: Number(node.getAttribute('data-z')||0),
              rotation: Number(node.getAttribute('data-rot')||0),
            };
          }

          function pctToGrid(p){ return Math.max(0, Math.min(HS_ISO.gridN-1, Math.round(p/(100/(HS_ISO.gridN-1))))); }
          function gridToPct(g){ return Math.max(0, Math.min(100, Math.round(g * (100/(HS_ISO.gridN-1))))); }

          function ensurePixi(force=false){
            const container = document.getElementById('corner-canvas');
            if (!container) return;
            if (PIXI_APP && !force) return;
            if (PIXI_APP && force) { PIXI_APP.destroy(true, {children:true, texture:true, baseTexture:true}); PIXI_APP = null; }

            PIXI_APP = new PIXI.Application({ backgroundAlpha: 0, resizeTo: container, antialias: true });
            container.innerHTML = '';
            container.appendChild(PIXI_APP.view);

            const stage = PIXI_APP.stage;
            // desenhar piso com Graphics
            drawFloor(stage);
            // criar itens a partir de window.__cornerItems
            SCENE.items.clear();
            (window.__cornerItems || []).forEach(addOrUpdateItem);
            // handlers
            window.addEventListener('keydown', onKey);
          }

          function drawFloor(stage){
            const g = new PIXI.Graphics();
            const container = document.getElementById('corner-canvas');
            const { gridN, tileW, tileH } = HS_ISO;
            for(let i=0;i<gridN;i++){
              for(let j=0;j<gridN;j++){
                const { sx, sy } = HS_ISO.project(container, i, j);
                const diamond = new PIXI.Graphics();
                diamond.lineStyle(1, 0x7c3aed, 0.18);
                diamond.beginFill(0x7c3aed, 0.10);
                // desenha diamante (rotacionado) - converter para pontos isométricos aproximados
                const w = tileW; const h = tileH;
                diamond.drawPolygon([
                  sx, sy - h/2,
                  sx + w/2, sy,
                  sx, sy + h/2,
                  sx - w/2, sy
                ]);
                diamond.endFill();
                // efeito sutil
                g.addChild(diamond);
              }
            }
            stage.addChild(g);
          }

          function spriteFor(item){
            // desenha um bloco básico representando o item (pode evoluir para atlas)
            const c = new PIXI.Container();
            const body = new PIXI.Graphics();
            body.lineStyle(1, 0x6b21a8, 0.4);
            body.beginFill(0xffffff, 0.10);
            body.drawRoundedRect(-16, -16, 32, 32, 8);
            body.endFill();
            // ícone minimalista (diferencia levemente)
            const deco = new PIXI.Graphics();
            deco.lineStyle(2, 0xe879f9, 0.9);
            if (item.item_key === 'table') {
              deco.drawCircle(0, -4, 8);
              deco.moveTo(-10, 8); deco.lineTo(10, 8);
            } else if (item.item_key === 'chair') {
              deco.drawRect(-8, -6, 16, 8);
              deco.moveTo(-10, 8); deco.lineTo(10, 8);
            } else if (item.item_key === 'plant') {
              deco.moveTo(0, -10); deco.lineTo(0, 4);
              deco.drawPolygon([-6,4, 6,4, 2,12, -2,12]);
            } else if (item.item_key === 'lamp') {
              deco.drawPolygon([-8,-8, 8,-8, 4,-14, -4,-14]);
              deco.moveTo(0,-8); deco.lineTo(0,10);
            } else {
              deco.drawCircle(0,0,6);
            }
            c.addChild(body, deco);
            // sombra 
            const shadow = new PIXI.Graphics();
            shadow.beginFill(0x000000, 0.18);
            shadow.drawEllipse(0, 18, 14, 4);
            shadow.endFill();
            shadow.zIndex = -1;
            c.addChild(shadow);
            c.eventMode = 'static';
            c.cursor = 'pointer';
            return c;
          }

          function addOrUpdateItem(item){
            const container = document.getElementById('corner-canvas');
            const { sx, sy } = HS_ISO.project(container, pctToGrid(item.x), pctToGrid(item.y));
            const sy3d = sy - item.z * (HS_ISO.tileH/2);
            let entry = SCENE.items.get(item.id);
            if (!entry){
              const sprite = spriteFor(item);
              sprite.x = sx; sprite.y = sy3d; sprite.rotation = (item.rotation||0) * Math.PI/180;
              sprite.alpha = 0.98;
              sprite.on('pointerdown', (e)=> startDrag(item.id, e));
              sprite.on('pointertap', ()=> selectItem(item.id));
              PIXI_APP.stage.addChild(sprite);
              entry = { item: {...item}, sprite };
              SCENE.items.set(item.id, entry);
            } else {
              entry.item = {...item};
              entry.sprite.x = sx; entry.sprite.y = sy3d; entry.sprite.rotation = (item.rotation||0)*Math.PI/180;
            }
            sortByDepth();
          }

          function sortByDepth(){
            // ordenar pelo y para profundidade
            const arr = Array.from(SCENE.items.values());
            arr.sort((a,b)=> a.sprite.y - b.sprite.y);
            arr.forEach((e,i)=> e.sprite.zIndex = 100+i);
            PIXI_APP.stage.sortChildren();
          }

          let DRAG = null;
          function startDrag(id, e){
            selectItem(id);
            DRAG = { id };
            const up = ()=>{ if (!DRAG) return; finishDrag(); window.removeEventListener('pointerup', up); window.removeEventListener('pointermove', move); };
            const move = (ev)=> dragMove(ev);
            window.addEventListener('pointerup', up);
            window.addEventListener('pointermove', move);
          }
          function dragMove(ev){
            if (!DRAG) return;
            const entry = SCENE.items.get(DRAG.id); if (!entry) return;
            const container = document.getElementById('corner-canvas');
            const rect = container.getBoundingClientRect();
            const px = ev.clientX - rect.left; const py = ev.clientY - rect.top;
            // busca célula mais próxima
            let best = { d: Infinity, gx:0, gy:0, sx:0, sy:0 };
            for (let i=0;i<HS_ISO.gridN;i++){
              for (let j=0;j<HS_ISO.gridN;j++){
                const { sx, sy } = HS_ISO.project(container, i, j);
                const sy3d = sy - (entry.item.z||0) * (HS_ISO.tileH/2);
                const dx = sx-px, dy = sy3d-py; const d = dx*dx+dy*dy;
                if (d < best.d) best = { d, gx:i, gy:j, sx, sy:sy3d };
              }
            }
            entry.sprite.x = best.sx; entry.sprite.y = best.sy;
            DRAG.gx = best.gx; DRAG.gy = best.gy;
          }
          async function finishDrag(){
            const entry = SCENE.items.get(DRAG.id); if (!entry) { DRAG=null; return; }
            const xPct = gridToPct(DRAG.gx); const yPct = gridToPct(DRAG.gy);
            const ok = await savePosition(DRAG.id, xPct, yPct);
            if (ok){ entry.item.x = xPct; entry.item.y = yPct; }
            sortByDepth();
            DRAG=null;
          }

          function selectItem(id){
            SCENE.selectedId = id;
            // realce leve
            SCENE.items.forEach(({sprite},key)=>{ sprite.scale.set(key===id?1.06:1.0); });
          }

          async function savePosition(id, x, y){
            const CSRF = (document.querySelector('meta[name="csrf-token"]')||{}).content || '';
            try{
              const res = await fetch(`/corner/items/${id}/position`, { method:'POST', headers:{ 'Content-Type':'application/json','X-CSRF-Token':CSRF,'HX-Request':'true' }, body: JSON.stringify({x,y}) });
              return res.ok;
            }catch(e){ console.error(e); return false; }
          }
          async function saveNudge(id, dx=0, dy=0, drot=0){
            const CSRF = (document.querySelector('meta[name="csrf-token"]')||{}).content || '';
            try{
              const res = await fetch(`/corner/items/${id}/nudge`, { method:'POST', headers:{ 'Content-Type':'application/json','X-CSRF-Token':CSRF,'HX-Request':'true' }, body: JSON.stringify({dx,dy,drot}) });
              if (!res.ok) return false; const html = await res.text();
              const node = htmlToNode(html);
              const data = domItemToData(node);
              addOrUpdateItem(data);
              return true;
            }catch(e){ console.error(e); return false; }
          }
          async function saveHeight(id, dz){
            const CSRF = (document.querySelector('meta[name="csrf-token"]')||{}).content || '';
            try{
              const res = await fetch(`/corner/items/${id}/height`, { method:'POST', headers:{ 'Content-Type':'application/json','X-CSRF-Token':CSRF,'HX-Request':'true' }, body: JSON.stringify({dz}) });
              if (!res.ok) return false; const html = await res.text();
              const node = htmlToNode(html);
              const data = domItemToData(node);
              addOrUpdateItem(data);
              return true;
            }catch(e){ console.error(e); return false; }
          }
          async function deleteItem(id){
            const CSRF = (document.querySelector('meta[name="csrf-token"]')||{}).content || '';
            try{
              const res = await fetch(`/corner/items/${id}/delete`, { method:'POST', headers:{ 'X-CSRF-Token':CSRF,'HX-Request':'true' } });
              if (!res.ok) return false; removeSprite(id); return true;
            }catch(e){ console.error(e); return false; }
          }

          function htmlToNode(html){ const t=document.createElement('div'); t.innerHTML=html.trim(); return t.firstElementChild; }
          function removeSprite(id){ const e = SCENE.items.get(id); if (!e) return; e.sprite.destroy(); SCENE.items.delete(id); }

          async function onKey(ev){
            if (!SCENE.selectedId) return;
            const id = SCENE.selectedId; const entry = SCENE.items.get(id); if (!entry) return;
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(ev.key)) {
              ev.preventDefault();
              const delta = (k)=> k==='ArrowLeft'?-2:k==='ArrowRight'?2:0;
              const dx = delta(ev.key); const dy = ev.key==='ArrowUp'?-2:ev.key==='ArrowDown'?2:0;
              if (dx||dy) await saveNudge(id, dx, dy, 0);
            } else if (ev.key.toLowerCase()==='q') { ev.preventDefault(); await saveNudge(id,0,0,-15); }
            else if (ev.key.toLowerCase()==='e') { ev.preventDefault(); await saveNudge(id,0,0, 15); }
            else if (ev.key==='PageUp' || ev.key==='+') { ev.preventDefault(); await saveHeight(id, 1); }
            else if (ev.key==='PageDown' || ev.key==='-') { ev.preventDefault(); await saveHeight(id,-1); }
            else if (ev.key==='Delete') { ev.preventDefault(); await deleteItem(id); }
          }
