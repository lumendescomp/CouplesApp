<div class="space-y-6">
  <header class="flex items-center justify-between">
    <h1 class="text-2xl font-semibold text-violet-100">Nosso cantinho</h1>
    <form
      id="add-item-form"
      hx-post="/corner/items"
      hx-target="#corner-outbox"
      hx-swap="innerHTML"
      class="flex items-center gap-2"
    >
      <select
        name="item_key"
        class="bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100"
      >
        <option value="table">Mesa</option>
        <option value="chair">Cadeira</option>
        <option value="plant">Planta</option>
        <option value="lamp">Lumin√°ria</option>
        <option value="sofa">Sof√°</option>
        <option value="tv">TV</option>
      </select>
      <button
        class="px-3 py-2 rounded bg-white/10 text-violet-100 hover:bg-white/20"
        type="submit"
      >
        Adicionar
      </button>
      <input type="hidden" name="_csrf" value="<%= csrfToken %>" />
    </form>
  </header>

  <div class="grid grid-cols-[1fr_280px] gap-6">
    <!-- Canvas do cantinho -->
    <section
      class="relative rounded-xl border border-violet-700/40 bg-white/5 overflow-hidden min-h-[420px]"
    >
      <div id="corner-canvas" class="absolute inset-0"></div>
      <!-- Overlay de a√ß√µes do item selecionado -->
      <div
        id="corner-overlay"
        class="absolute z-20 hidden"
        style="pointer-events: auto"
      >
        <div
          class="flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md"
        >
          <button
            id="btn-rotate-left"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Girar -15¬∞"
          >
            ‚Ü∫
          </button>
          <button
            id="btn-rotate-right"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Girar +15¬∞"
          >
            ‚Üª
          </button>
          <span class="mx-1 text-white/30">|</span>
          <button
            id="btn-height-up"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Subir"
          >
            ‚§¥
          </button>
          <button
            id="btn-height-down"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Descer"
          >
            ‚§µ
          </button>
          <span class="mx-1 text-white/30">|</span>
          <button
            id="btn-delete"
            class="px-2 py-1 bg-rose-600/80 hover:bg-rose-600 text-white rounded"
            title="Remover"
          >
            üóë
          </button>
        </div>
      </div>
      <div id="corner-outbox" class="hidden" aria-hidden="true"></div>
    </section>

    <!-- Invent√°rio -->
    <aside class="rounded-xl border border-violet-700/40 bg-white/5 p-3">
      <h2 class="text-lg text-violet-100 mb-3">Invent√°rio</h2>
      <div class="mb-3">
        <input
          id="inventory-search"
          type="text"
          class="w-full bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100 placeholder-violet-300/60 focus:outline-none focus:ring-2 focus:ring-violet-500/50"
          placeholder="Buscar item..."
          autocomplete="off"
        />
      </div>
      <ul id="inventory-list" class="space-y-2 text-violet-200 text-sm">
        <li>Mesa</li>
        <li>Cadeira</li>
        <li>Planta</li>
        <li>Lumin√°ria</li>
        <li>Sof√°</li>
        <li>TV</li>
      </ul>
      <p class="mt-4 text-xs text-violet-300/80">
        Arraste itens no canvas (vers√µes futuras).
      </p>
    </aside>
  </div>
</div>

<!-- Dados iniciais para o Pixi (evita EJS direto no JS) -->
<script type="application/json" id="corner-items-data">
  <%- JSON.stringify(items || []) %>
</script>

<script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
<script src="https://unpkg.com/@pixi/unsafe-eval@7.x/dist/unsafe-eval.min.js"></script>
<script>
  // Dados iniciais vindos do servidor (via tag JSON)
  (function () {
    try {
      const el = document.getElementById("corner-items-data");
      window.__cornerItems = el ? JSON.parse(el.textContent || "[]") : [];
    } catch {
      window.__cornerItems = [];
    }
  })();
  // Isolar todo o c√≥digo da p√°gina em um controller para evitar redeclara√ß√µes em navega√ß√£o htmx
  (function CornerPage() {
    // Se j√° existe uma inst√¢ncia anterior, destr√≥i antes de inicializar
    if (
      window.__CornerInstance &&
      typeof window.__CornerInstance.destroy === "function"
    ) {
      try {
        window.__CornerInstance.destroy();
      } catch (_) {}
    }

    // Proje√ß√£o isom√©trica simples (escopo local)
    const HS_ISO = {
      gridN: 10,
      tileW: 72,
      tileH: 36,
      sizes: {
        table: { w: 2, h: 1 },
        chair: { w: 1, h: 1 },
        plant: { w: 1, h: 1 },
        lamp: { w: 1, h: 1 },
        sofa: { w: 2, h: 1 },
        tv: { w: 2, h: 1 },
      },
      project(container, gx, gy) {
        const { tileW, tileH, gridN } = this;
        const cw = container.clientWidth || 800;
        const ch = container.clientHeight || 420;
        const gridPixelH = gridN * tileH;
        const x0 = cw / 2;
        const y0 = Math.max(24, (ch - gridPixelH) / 2) + tileH;
        const sx = x0 + (gx - gy) * (tileW / 2);
        const sy = y0 + (gx + gy) * (tileH / 2);
        return { sx, sy };
      },
    };

    // ===== Implementa√ß√£o Pixi =====
    let PIXI_APP = null;
    const SCENE = { items: new Map(), selectedId: null };
    const BOUND = { resize: null, keydown: null, htmx: null };

    function pctToGrid(p) {
      return Math.max(
        0,
        Math.min(HS_ISO.gridN - 1, Math.round(p / (100 / (HS_ISO.gridN - 1))))
      );
    }
    function gridToPct(g) {
      return Math.max(
        0,
        Math.min(100, Math.round(g * (100 / (HS_ISO.gridN - 1))))
      );
    }
    function domItemToData(node) {
      return {
        id: Number(node.getAttribute("data-id")),
        item_key: node.getAttribute("data-key") || "unknown",
        x: Number(node.getAttribute("data-x") || 50),
        y: Number(node.getAttribute("data-y") || 50),
        z: Number(node.getAttribute("data-z") || 0),
        rotation: Number(node.getAttribute("data-rot") || 0),
      };
    }

    function ensurePixi(force = false) {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      if (PIXI_APP && !force) return;
      if (PIXI_APP && force) {
        PIXI_APP.destroy(true, {
          children: true,
          texture: true,
          baseTexture: true,
        });
        PIXI_APP = null;
      }

      PIXI_APP = new PIXI.Application({
        backgroundAlpha: 0,
        resizeTo: container,
        antialias: true,
      });
      container.innerHTML = "";
      container.appendChild(PIXI_APP.view);

      drawFloor(PIXI_APP.stage);
      SCENE.items.clear();
      (window.__cornerItems || []).forEach(addOrUpdateItem);

      // teclado
      BOUND.keydown = (ev) => onKey(ev);
      window.addEventListener("keydown", BOUND.keydown);
    }

    function drawFloor(stage) {
      const container = document.getElementById("corner-canvas");
      const g = new PIXI.Graphics();
      const { gridN, tileW, tileH } = HS_ISO;
      for (let i = 0; i < gridN; i++) {
        for (let j = 0; j < gridN; j++) {
          const { sx, sy } = HS_ISO.project(container, i, j);
          const diamond = new PIXI.Graphics();
          diamond.lineStyle(1, 0x7c3aed, 0.18);
          diamond.beginFill(0x7c3aed, 0.1);
          const w = tileW,
            h = tileH;
          diamond.drawPolygon([
            sx,
            sy - h / 2,
            sx + w / 2,
            sy,
            sx,
            sy + h / 2,
            sx - w / 2,
            sy,
          ]);
          diamond.endFill();
          g.addChild(diamond);
        }
      }
      stage.addChild(g);
    }

    function spriteFor(item) {
      const c = new PIXI.Container();
      const textures = {
        table: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='8' y='24' width='48' height='16' rx='4' fill='%23c4b5fd'/><rect x='12' y='40' width='8' height='12' fill='%239b87f5'/><rect x='44' y='40' width='8' height='12' fill='%239b87f5'/></svg>`,
        chair: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='20' y='20' width='24' height='12' rx='3' fill='%23f0abfc'/><rect x='18' y='32' width='28' height='10' rx='3' fill='%23d946ef'/><rect x='22' y='42' width='6' height='12' fill='%239b87f5'/><rect x='36' y='42' width='6' height='12' fill='%239b87f5'/></svg>`,
        plant: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='18' r='8' fill='%234ade80'/><path d='M32 26v24' stroke='%230a0a0a' stroke-width='3'/><rect x='22' y='42' width='20' height='12' rx='2' fill='%238b5cf6'/></svg>`,
        lamp: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><polygon points='20,18 44,18 38,8 26,8' fill='%23fde68a'/><rect x='30' y='18' width='4' height='26' fill='%239b87f5'/><rect x='24' y='44' width='16' height='6' rx='2' fill='%237c3aed'/></svg>`,
        sofa: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='8' y='26' width='80' height='22' rx='6' fill='%23a78bfa'/><rect x='8' y='16' width='80' height='14' rx='6' fill='%23c4b5fd'/><rect x='12' y='48' width='10' height='6' fill='%239b87f5'/><rect x='74' y='48' width='10' height='6' fill='%239b87f5'/></svg>`,
        tv: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='10' y='8' width='76' height='46' rx='6' fill='%230a0a0a'/><rect x='14' y='12' width='68' height='38' rx='4' fill='%23252525'/><rect x='40' y='54' width='16' height='4' fill='%237c3aed'/></svg>`,
      };
      const url =
        textures[item.item_key] ||
        `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='10' fill='%23a78bfa'/></svg>`;
      const tex = PIXI.Texture.from(url);
      const spr = new PIXI.Sprite(tex);
      spr.anchor.set(0.5);
      const scale =
        item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
      spr.scale.set(scale);
      const shadow = new PIXI.Graphics();
      shadow.beginFill(0x000000, 0.18);
      shadow.drawEllipse(0, 18, 14, 4);
      shadow.endFill();
      shadow.zIndex = -1;
      c.addChild(shadow, spr);
      c.eventMode = "static";
      c.cursor = "pointer";
      return c;
    }

    function addOrUpdateItem(item) {
      const container = document.getElementById("corner-canvas");
      const { sx, sy } = HS_ISO.project(
        container,
        pctToGrid(item.x),
        pctToGrid(item.y)
      );
      const sy3d = sy - item.z * (HS_ISO.tileH / 2);
      let entry = SCENE.items.get(item.id);
      if (!entry) {
        const sprite = spriteFor(item);
        sprite.x = sx;
        sprite.y = sy3d;
        sprite.rotation = ((item.rotation || 0) * Math.PI) / 180;
        sprite.alpha = 0.98;
        sprite.on("pointerdown", (e) => startDrag(item.id, e));
        sprite.on("pointertap", () => selectItem(item.id));
        PIXI_APP.stage.addChild(sprite);
        entry = { item: { ...item }, sprite };
        SCENE.items.set(item.id, entry);
      } else {
        entry.item = { ...item };
        entry.sprite.x = sx;
        entry.sprite.y = sy3d;
        entry.sprite.rotation = ((item.rotation || 0) * Math.PI) / 180;
      }
      sortByDepth();
    }

    function sortByDepth() {
      const arr = Array.from(SCENE.items.values());
      arr.sort((a, b) => a.sprite.y - b.sprite.y);
      arr.forEach((e, i) => (e.sprite.zIndex = 100 + i));
      PIXI_APP.stage.sortChildren();
    }

    let DRAG = null;
    function startDrag(id, e) {
      selectItem(id);
      DRAG = { id };
      const up = () => {
        if (!DRAG) return;
        finishDrag();
        window.removeEventListener("pointerup", up);
        window.removeEventListener("pointermove", move);
      };
      const move = (ev) => dragMove(ev);
      window.addEventListener("pointerup", up);
      window.addEventListener("pointermove", move);
    }
    function dragMove(ev) {
      if (!DRAG) return;
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) return;
      const container = document.getElementById("corner-canvas");
      const rect = container.getBoundingClientRect();
      const px = ev.clientX - rect.left;
      const py = ev.clientY - rect.top;
      let best = { d: Infinity, gx: 0, gy: 0, sx: 0, sy: 0 };
      for (let i = 0; i < HS_ISO.gridN; i++) {
        for (let j = 0; j < HS_ISO.gridN; j++) {
          const { sx, sy } = HS_ISO.project(container, i, j);
          const sy3d = sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
          const dx = sx - px,
            dy = sy3d - py;
          const d = dx * dx + dy * dy;
          if (d < best.d) best = { d, gx: i, gy: j, sx, sy: sy3d };
        }
      }
      const size = HS_ISO.sizes[entry.item.item_key] || { w: 1, h: 1 };
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const gx = clamp(best.gx, 0, HS_ISO.gridN - size.w);
      const gy = clamp(best.gy, 0, HS_ISO.gridN - size.h);
      const p = HS_ISO.project(container, gx, gy);
      const sy3d = p.sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
      entry.sprite.x = p.sx;
      entry.sprite.y = sy3d;
      DRAG.gx = gx;
      DRAG.gy = gy;
      if (SCENE.selectedId === DRAG.id) updateOverlayPosition(DRAG.id);
    }
    async function finishDrag() {
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) {
        DRAG = null;
        return;
      }
      const xPct = gridToPct(DRAG.gx);
      const yPct = gridToPct(DRAG.gy);
      const ok = await savePosition(DRAG.id, xPct, yPct);
      if (ok) {
        entry.item.x = xPct;
        entry.item.y = yPct;
      }
      sortByDepth();
      DRAG = null;
    }

    function selectItem(id) {
      SCENE.selectedId = id;
      SCENE.items.forEach(({ sprite }, key) => {
        sprite.scale.set(key === id ? 1.06 : 1.0);
      });
      updateOverlayPosition(id);
      bindOverlayActions(id);
    }

    function updateOverlayPosition(id) {
      const entry = SCENE.items.get(id);
      const overlay = document.getElementById("corner-overlay");
      const container = document.getElementById("corner-canvas");
      if (!entry || !overlay || !container) return;
      overlay.classList.remove("hidden");
      overlay.style.left = Math.round(entry.sprite.x) + "px";
      overlay.style.top = Math.round(entry.sprite.y) + "px";
      const gap = 8;
      const h = overlay.offsetHeight || 32;
      overlay.style.transform = `translate(-50%, -${h + gap}px)`;
    }

    function bindOverlayActions(id) {
      const overlay = document.getElementById("corner-overlay");
      if (!overlay) return;
      const idSel = id;
      const btnDel = document.getElementById("btn-delete");
      const btnRL = document.getElementById("btn-rotate-left");
      const btnRR = document.getElementById("btn-rotate-right");
      const btnHU = document.getElementById("btn-height-up");
      const btnHD = document.getElementById("btn-height-down");
      if (btnDel)
        btnDel.onclick = async (e) => {
          e.stopPropagation();
          await deleteItem(idSel);
          overlay.classList.add("hidden");
        };
      if (btnRL)
        btnRL.onclick = async (e) => {
          e.stopPropagation();
          await saveNudge(idSel, 0, 0, -15);
          updateOverlayPosition(idSel);
        };
      if (btnRR)
        btnRR.onclick = async (e) => {
          e.stopPropagation();
          await saveNudge(idSel, 0, 0, 15);
          updateOverlayPosition(idSel);
        };
      if (btnHU)
        btnHU.onclick = async (e) => {
          e.stopPropagation();
          await saveHeight(idSel, 1);
          updateOverlayPosition(idSel);
        };
      if (btnHD)
        btnHD.onclick = async (e) => {
          e.stopPropagation();
          await saveHeight(idSel, -1);
          updateOverlayPosition(idSel);
        };
    }

    async function savePosition(id, x, y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/position`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ x, y }),
        });
        return res.ok;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveNudge(id, dx = 0, dy = 0, drot = 0) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/nudge`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dx, dy, drot }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveHeight(id, dz) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/height`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dz }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function deleteItem(id) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/delete`, {
          method: "POST",
          headers: { "X-CSRF-Token": CSRF, "HX-Request": "true" },
        });
        if (!res.ok) return false;
        removeSprite(id);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    function htmlToNode(html) {
      const t = document.createElement("div");
      t.innerHTML = html.trim();
      return t.firstElementChild;
    }
    function removeSprite(id) {
      const e = SCENE.items.get(id);
      if (!e) return;
      e.sprite.destroy({ children: true });
      SCENE.items.delete(id);
    }

    // resize handler
    function bindResize() {
      BOUND.resize = () => {
        if (!PIXI_APP) return;
        SCENE.items.forEach(({ item }) => addOrUpdateItem(item));
        if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
      };
      window.addEventListener("resize", BOUND.resize);
    }

    // Integra√ß√£o com htmx (listener removido no destroy)
    function bindHtmx() {
      BOUND.htmx = (e) => {
        const target = e && e.detail && e.detail.target;
        if (target && target.id === "corner-outbox") {
          const node = target.querySelector(".corner-item");
          if (node) {
            const item = domItemToData(node);
            try {
              window.__cornerItems = Array.isArray(window.__cornerItems)
                ? window.__cornerItems
                : [];
              window.__cornerItems.push(item);
            } catch (_) {}
            addOrUpdateItem(item);
            selectItem(item.id);
            target.innerHTML = "";
          }
        }
      };
      document.addEventListener("htmx:afterSwap", BOUND.htmx);
    }

    // Teclado
    async function onKey(ev) {
      if (!SCENE.selectedId) return;
      const id = SCENE.selectedId;
      const entry = SCENE.items.get(id);
      if (!entry) return;
      if (
        ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(ev.key)
      ) {
        ev.preventDefault();
        const delta = (k) =>
          k === "ArrowLeft" ? -2 : k === "ArrowRight" ? 2 : 0;
        const dx = delta(ev.key);
        const dy = ev.key === "ArrowUp" ? -2 : ev.key === "ArrowDown" ? 2 : 0;
        if (dx || dy) await saveNudge(id, dx, dy, 0);
      } else if (ev.key.toLowerCase() === "q") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, -15);
      } else if (ev.key.toLowerCase() === "e") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, 15);
      } else if (ev.key === "PageUp" || ev.key === "+") {
        ev.preventDefault();
        await saveHeight(id, 1);
      } else if (ev.key === "PageDown" || ev.key === "-") {
        ev.preventDefault();
        await saveHeight(id, -1);
      } else if (ev.key === "Delete") {
        ev.preventDefault();
        await deleteItem(id);
      }
    }

    // Expor e inicializar
    function destroy() {
      try {
        if (BOUND.keydown) window.removeEventListener("keydown", BOUND.keydown);
        if (BOUND.resize) window.removeEventListener("resize", BOUND.resize);
        if (BOUND.htmx)
          document.removeEventListener("htmx:afterSwap", BOUND.htmx);
      } catch (_) {}
      try {
        const container = document.getElementById("corner-canvas");
        if (PIXI_APP) {
          PIXI_APP.destroy(true, {
            children: true,
            texture: true,
            baseTexture: true,
          });
          if (container) container.innerHTML = "";
        }
      } catch (_) {}
      PIXI_APP = null;
    }

    window.__CornerInstance = { destroy };
    // init now (scripts de p√°ginas htmx executam ap√≥s inser√ß√£o no DOM)
    ensurePixi();
    bindResize();
    bindHtmx();

    // filtro de invent√°rio
    const search = document.getElementById("inventory-search");
    const list = document.getElementById("inventory-list");
    if (search && list) {
      const onInput = () => {
        const q = (search.value || "").trim().toLowerCase();
        list.querySelectorAll("li").forEach((li) => {
          const txt = (li.textContent || "").toLowerCase();
          li.style.display = !q || txt.includes(q) ? "" : "none";
        });
      };
      search.addEventListener("input", onInput);
    }
  })();
</script>
