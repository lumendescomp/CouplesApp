<div class="space-y-6">
  <header class="flex items-center justify-between">
    <h1 class="text-2xl font-semibold text-violet-100">Nosso cantinho</h1>
    <form
      id="add-item-form"
      hx-post="/corner/items"
      hx-target="#corner-outbox"
      hx-swap="innerHTML"
      class="flex items-center gap-2"
    >
      <select
        name="item_key"
        class="bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100"
      >
        <option value="table">Mesa</option>
        <option value="chair">Cadeira</option>
        <option value="plant">Planta</option>
        <option value="lamp">Lumin√°ria</option>
        <option value="sofa">Sof√°</option>
        <option value="tv">TV</option>
      </select>
      <button
        class="px-3 py-2 rounded bg-white/10 text-violet-100 hover:bg-white/20"
        type="submit"
      >
        Adicionar
      </button>

      <input type="hidden" name="_csrf" value="<%= csrfToken %>" />
    </form>
  </header>

  <div class="grid grid-cols-[1fr_280px] gap-6">
    <!-- Canvas do cantinho -->
    <section
      class="relative rounded-xl border border-violet-700/40 bg-white/5 overflow-hidden min-h-[420px]"
    >
      <div id="corner-canvas" class="absolute inset-0"></div>
      <!-- Toolbar de Zoom -->
      <div
        class="absolute top-2 left-2 z-30 flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md"
      >
        <button
          id="btn-zoom-out"
          class="px-2 py-1 hover:bg-white/10 rounded"
          title="Zoom out"
        >
          ‚àí
        </button>
        <button
          id="btn-zoom-reset"
          class="px-2 py-1 hover:bg-white/10 rounded text-xs"
          title="Resetar para 100%"
        >
          100%
        </button>
        <button
          id="btn-zoom-in"
          class="px-2 py-1 hover:bg-white/10 rounded"
          title="Zoom in"
        >
          +
        </button>
      </div>
      <!-- Overlay de a√ß√µes do item selecionado -->
      <div
        id="corner-overlay"
        class="absolute z-20 hidden"
        style="pointer-events: auto"
      >
        <div
          class="flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md"
        >
          <button
            id="btn-layer-down"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Enviar para tr√°s"
          >
            ‚§∫
          </button>
          <button
            id="btn-layer-up"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Trazer para frente"
          >
            ‚§ª
          </button>
          <button
            id="btn-layer-bottom"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Enviar para o fundo"
          >
            ‚§ì
          </button>
          <button
            id="btn-layer-top"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Trazer para o topo"
          >
            ‚§í
          </button>
          <span class="mx-1 text-white/30">|</span>
          <label for="overlay-scale" class="sr-only">Escala</label>
          <input
            id="overlay-scale"
            type="number"
            step="0.05"
            min="0.25"
            max="2"
            value="1.0"
            class="w-20 bg-white/10 border border-violet-700/40 rounded px-1 py-0.5 text-violet-100 text-xs"
            title="Escala (0.25‚Äî2.0)"
          />
          <button
            id="btn-scale-dec"
            class="px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Escala -0.05"
          >
            ‚àí
          </button>
          <button
            id="btn-scale-inc"
            class="px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Escala +0.05"
          >
            +
          </button>
          <button
            id="btn-delete"
            class="px-2 py-1 bg-rose-600/80 hover:bg-rose-600 text-white rounded"
            title="Remover"
          >
            üóë
          </button>
        </div>
      </div>
      <div id="corner-outbox" class="hidden" aria-hidden="true"></div>
    </section>

    <!-- Invent√°rio -->
    <aside class="rounded-xl border border-violet-700/40 bg-white/5 p-3">
      <h2 class="text-lg text-violet-100 mb-3">Invent√°rio</h2>
      <div class="mb-3">
        <input
          id="inventory-search"
          type="text"
          class="w-full bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100 placeholder-violet-300/60 focus:outline-none focus:ring-2 focus:ring-violet-500/50"
          placeholder="Buscar item..."
          autocomplete="off"
        />
      </div>
      <ul id="inventory-list" class="space-y-2 text-violet-200 text-sm">
        <li>Mesa</li>
        <li>Cadeira</li>
        <li>Planta</li>
        <li>Lumin√°ria</li>
        <li>Sof√°</li>
        <li>TV</li>
      </ul>
      <p class="mt-4 text-xs text-violet-300/80">
        Arraste itens no canvas (vers√µes futuras).
      </p>
    </aside>
  </div>
</div>

<!-- Dados iniciais para o Pixi (evita EJS direto no JS) -->
<script type="application/json" id="corner-items-data">
  <%- JSON.stringify(items || []) %>
</script>

<script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
<script src="https://unpkg.com/@pixi/unsafe-eval@7.x/dist/unsafe-eval.min.js"></script>
<script>
  // Dados iniciais vindos do servidor (via tag JSON)
  (function () {
    try {
      const el = document.getElementById("corner-items-data");
      window.__cornerItems = el ? JSON.parse(el.textContent || "[]") : [];
    } catch {
      window.__cornerItems = [];
    }
  })();
  // Isolar todo o c√≥digo da p√°gina em um controller para evitar redeclara√ß√µes em navega√ß√£o htmx
  (function CornerPage() {
    // Se j√° existe uma inst√¢ncia anterior, destr√≥i antes de inicializar
    if (
      window.__CornerInstance &&
      typeof window.__CornerInstance.destroy === "function"
    ) {
      try {
        window.__CornerInstance.destroy();
      } catch (_) {}
    }

    // Proje√ß√£o isom√©trica simples (escopo local)
    const HS_ISO = {
      gridN: 10,
      tileW: 72,
      tileH: 36,
      // origem fixa no espa√ßo do "world" (n√£o depende do container ap√≥s inicializar)
      originX: 0,
      originY: 0,
      sizes: {
        table: { w: 2, h: 1 },
        chair: { w: 1, h: 1 },
        plant: { w: 1, h: 1 },
        lamp: { w: 1, h: 1 },
        sofa: { w: 2, h: 1 },
        tv: { w: 2, h: 1 },
      },
      // Define a origem no espa√ßo do world, centralizando a grade inicialmente
      computeOrigin(container) {
        const { tileH, gridN } = this;
        const cw = container.clientWidth || 800;
        const ch = container.clientHeight || 420;
        const gridPixelH = gridN * tileH;
        this.originX = cw / 2;
        this.originY = Math.max(24, (ch - gridPixelH) / 2) + tileH;
      },
      // Projeta coordenadas de grade para coordenadas locais do world
      projectWorld(gx, gy) {
        const { tileW, tileH, originX, originY } = this;
        const sx = originX + (gx - gy) * (tileW / 2);
        const sy = originY + (gx + gy) * (tileH / 2);
        return { sx, sy };
      },
    };

    // ===== Implementa√ß√£o Pixi =====
    let PIXI_APP = null;
    const SCENE = {
      items: new Map(),
      selectedId: null,
      world: null,
      zoom: 1,
      spaceDown: false,
      pan: { active: false },
      floor: null,
    };
    const BOUND = {
      resize: null,
      keydown: null,
      keyup: null,
      htmx: null,
      click: null,
      pan: null,
    };

    function pctToGrid(p) {
      // Converte porcentagem para √≠ndice de grade com resolu√ß√£o de 0.25
      const step = 100 / (HS_ISO.gridN - 1);
      const gi = (Number(p) || 0) / step; // pode ser fracion√°rio
      // arredonda para o m√∫ltiplo de 0.25 mais pr√≥ximo
      const g025 = Math.round(gi * 4) / 4;
      return Math.max(0, Math.min(HS_ISO.gridN - 1, g025));
    }
    function gridToPct(g) {
      // Converte √≠ndice de grade (pode ter .5) para porcentagem sem arredondar
      const step = 100 / (HS_ISO.gridN - 1);
      const val = (Number(g) || 0) * step;
      // limita a duas casas decimais para estabilidade de rede/render
      return Math.max(0, Math.min(100, Number(val.toFixed(2))));
    }
    function domItemToData(node) {
      return {
        id: Number(node.getAttribute("data-id")),
        item_key: node.getAttribute("data-key") || "unknown",
        x: Number(node.getAttribute("data-x") || 50),
        y: Number(node.getAttribute("data-y") || 50),
        z: Number(node.getAttribute("data-z") || 0),
        rotation: Number(node.getAttribute("data-rot") || 0),
        scale: Number(node.getAttribute("data-scale") || 1.0),
        layer: Number(node.getAttribute("data-layer") || 0),
      };
    }

    async function loadAtlasIfAny() {
      const ATLAS = { ready: false, frames: {} };
      try {
        const res = await fetch("/public/assets/atlas/items.json", {
          cache: "no-store",
        });
        if (!res.ok) return ATLAS;
        const data = await res.json();
        // Caso 1: j√° veio pronto de Assets como spritesheet com .textures
        if (data && data.textures && typeof data.textures === "object") {
          ATLAS.ready = true;
          ATLAS.frames = data.textures;
          console.info("[corner] Atlas carregado (textures)");
          return ATLAS;
        }
        // Caso 2: mapa simples de imagens: { images: { key: url } }
        if (data && data.images && typeof data.images === "object") {
          const frames = {};
          // Carrega data: URIs manualmente em elementos Image para evitar fetch/GET inv√°lido
          for (const [k, url] of Object.entries(data.images)) {
            try {
              if (typeof url === "string" && url.startsWith("data:")) {
                const img = new Image();
                img.src = url;
                // decode() garante que a imagem est√° pronta
                if (img.decode) {
                  await img.decode();
                } else {
                  await new Promise((resolve) => {
                    img.onload = () => resolve();
                    img.onerror = () => resolve();
                  });
                }
                const base = PIXI.BaseTexture.from(img);
                frames[k] = new PIXI.Texture(base);
              } else {
                frames[k] = PIXI.Texture.from(url);
              }
            } catch (_) {
              // fallback simples para evitar quebra total
              frames[k] = PIXI.Texture.WHITE;
            }
          }
          ATLAS.ready = true;
          ATLAS.frames = frames;
          console.info("[corner] Atlas carregado (images map)");
          return ATLAS;
        }
        // Caso 3: TexturePacker style { frames, meta: { image } }
        if (data && data.frames && data.meta && data.meta.image) {
          let base;
          if (
            typeof data.meta.image === "string" &&
            data.meta.image.startsWith("data:")
          ) {
            const img = new Image();
            img.src = data.meta.image;
            if (img.decode) {
              await img.decode();
            } else {
              await new Promise((resolve) => {
                img.onload = () => resolve();
                img.onerror = () => resolve();
              });
            }
            base = PIXI.BaseTexture.from(img);
          } else {
            base = PIXI.BaseTexture.from(data.meta.image);
          }
          const ss = new PIXI.Spritesheet(base, data);
          await ss.parse();
          ATLAS.ready = true;
          ATLAS.frames = ss.textures;
          console.info("[corner] Atlas carregado (TexturePacker)");
          return ATLAS;
        }
      } catch (_) {
        // Sem atlas: usa SVG inline
      }
      return ATLAS;
    }

    async function ensurePixi(force = false) {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      if (PIXI_APP && !force) return;
      if (PIXI_APP && force) {
        PIXI_APP.destroy(true, {
          children: true,
          texture: true,
          baseTexture: true,
        });
        PIXI_APP = null;
      }

      PIXI_APP = new PIXI.Application({
        backgroundAlpha: 0,
        resizeTo: container,
        antialias: true,
      });
      container.innerHTML = "";
      container.appendChild(PIXI_APP.view);

      // container raiz do mundo para permitir zoom/pan
      SCENE.world = new PIXI.Container();
      SCENE.world.sortableChildren = true;
      PIXI_APP.stage.addChild(SCENE.world);

      // origem fixa do mundo para proje√ß√£o est√°vel
      HS_ISO.computeOrigin(container);
      drawFloor(SCENE.world);
      SCENE.items.clear();
      SCENE.atlas = await loadAtlasIfAny();
      (window.__cornerItems || []).forEach(addOrUpdateItem);

      // teclado (inclui Space para pan)
      const containerEl = document.getElementById("corner-canvas");
      BOUND.keydown = (ev) => {
        // ignora quando digitando em inputs
        const t = ev.target;
        const tag = (t && t.tagName) || "";
        const editing =
          tag === "INPUT" || tag === "TEXTAREA" || (t && t.isContentEditable);
        if (ev.code === "Space" && !editing) {
          if (!SCENE.spaceDown) {
            SCENE.spaceDown = true;
            if (containerEl) containerEl.style.cursor = "grab";
          }
          ev.preventDefault();
          return;
        }
        onKey(ev);
      };
      BOUND.keyup = (ev) => {
        if (ev.code === "Space") {
          SCENE.spaceDown = false;
          const el = document.getElementById("corner-canvas");
          // mant√©m 'grabbing' caso ainda esteja arrastando; sen√£o limpa
          if (el && !(SCENE.pan && SCENE.pan.active)) el.style.cursor = "";
        }
      };
      window.addEventListener("keydown", BOUND.keydown);
      window.addEventListener("keyup", BOUND.keyup);

      // zoom toolbar
      const btnIn = document.getElementById("btn-zoom-in");
      const btnOut = document.getElementById("btn-zoom-out");
      const btnReset = document.getElementById("btn-zoom-reset");
      if (btnIn) btnIn.onclick = () => setZoom((SCENE.zoom || 1) + 0.1);
      if (btnOut) btnOut.onclick = () => setZoom((SCENE.zoom || 1) - 0.1);
      if (btnReset) btnReset.onclick = () => setZoom(1);
    }

    function setZoom(value) {
      const container = document.getElementById("corner-canvas");
      if (!SCENE.world || !container) return;
      const rect = container.getBoundingClientRect();
      const mx = rect.width / 2;
      const my = rect.height / 2;
      const next = Math.max(0.6, Math.min(2.0, Number(value) || 1));
      const local = SCENE.world.toLocal(new PIXI.Point(mx, my));
      SCENE.world.pivot.set(local.x, local.y);
      SCENE.world.position.set(mx, my);
      SCENE.world.scale.set(next);
      SCENE.zoom = next;
      if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
    }

    function drawFloor(stage) {
      // limpa floor anterior
      if (SCENE.floor) {
        try {
          SCENE.floor.destroy({ children: true });
        } catch (_) {}
      }
      SCENE.floor = new PIXI.Container();
      const g = new PIXI.Container();
      const { gridN, tileW, tileH } = HS_ISO;
      for (let i = 0; i < gridN; i++) {
        for (let j = 0; j < gridN; j++) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const diamond = new PIXI.Graphics();
          diamond.lineStyle(1, 0x7c3aed, 0.18);
          diamond.beginFill(0x7c3aed, 0.1);
          const w = tileW,
            h = tileH;
          diamond.drawPolygon([
            sx,
            sy - h / 2,
            sx + w / 2,
            sy,
            sx,
            sy + h / 2,
            sx - w / 2,
            sy,
          ]);
          diamond.endFill();
          g.addChild(diamond);
        }
      }
      SCENE.floor.addChild(g);
      stage.addChild(SCENE.floor);
    }

    function textureFromUrl(url) {
      try {
        if (typeof url === "string" && url.startsWith("data:")) {
          const img = new Image();
          img.src = url;
          const base = PIXI.BaseTexture.from(img);
          return new PIXI.Texture(base);
        }
      } catch (_) {}
      return PIXI.Texture.from(url);
    }

    function spriteFor(item) {
      const c = new PIXI.Container();
      const textures = {
        table: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='8' y='24' width='48' height='16' rx='4' fill='%23c4b5fd'/><rect x='12' y='40' width='8' height='12' fill='%239b87f5'/><rect x='44' y='40' width='8' height='12' fill='%239b87f5'/></svg>`,
        chair: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='20' y='20' width='24' height='12' rx='3' fill='%23f0abfc'/><rect x='18' y='32' width='28' height='10' rx='3' fill='%23d946ef'/><rect x='22' y='42' width='6' height='12' fill='%239b87f5'/><rect x='36' y='42' width='6' height='12' fill='%239b87f5'/></svg>`,
        plant: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='18' r='8' fill='%234ade80'/><path d='M32 26v24' stroke='%230a0a0a' stroke-width='3'/><rect x='22' y='42' width='20' height='12' rx='2' fill='%238b5cf6'/></svg>`,
        lamp: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><polygon points='20,18 44,18 38,8 26,8' fill='%23fde68a'/><rect x='30' y='18' width='4' height='26' fill='%239b87f5'/><rect x='24' y='44' width='16' height='6' rx='2' fill='%237c3aed'/></svg>`,
        sofa: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='8' y='26' width='80' height='22' rx='6' fill='%23a78bfa'/><rect x='8' y='16' width='80' height='14' rx='6' fill='%23c4b5fd'/><rect x='12' y='48' width='10' height='6' fill='%239b87f5'/><rect x='74' y='48' width='10' height='6' fill='%239b87f5'/></svg>`,
        tv: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='10' y='8' width='76' height='46' rx='6' fill='%230a0a0a'/><rect x='14' y='12' width='68' height='38' rx='4' fill='%23252525'/><rect x='40' y='54' width='16' height='4' fill='%237c3aed'/></svg>`,
      };
      let tex = null;
      if (SCENE.atlas && SCENE.atlas.ready) {
        const key = item.item_key;
        const candidates = [key, `${key}.png`, `${key}.webp`, `${key}.jpg`];
        for (const k of candidates) {
          if (SCENE.atlas.frames[k]) {
            tex = SCENE.atlas.frames[k];
            break;
          }
        }
      }
      if (!tex) {
        const url =
          textures[item.item_key] ||
          `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='10' fill='%23a78bfa'/></svg>`;
        tex = textureFromUrl(url);
      }
      const spr = new PIXI.Sprite(tex);
      spr.anchor.set(0.5);
      const baseScale =
        item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
      const userScale = Number(item.scale || 1.0);
      spr.scale.set(baseScale * userScale);
      const shadow = new PIXI.Graphics();
      shadow.beginFill(0x000000, 0.18);
      shadow.drawEllipse(0, 18, 14, 4);
      shadow.endFill();
      shadow.zIndex = -1;
      c.addChild(shadow, spr);
      c.hsSpr = spr; // refer√™ncia ao sprite principal
      c.eventMode = "static";
      c.cursor = "pointer";
      return c;
    }

    function addOrUpdateItem(item) {
      const container = document.getElementById("corner-canvas");
      const { sx, sy } = HS_ISO.projectWorld(
        pctToGrid(item.x),
        pctToGrid(item.y)
      );
      const sy3d = sy - item.z * (HS_ISO.tileH / 2);
      let entry = SCENE.items.get(item.id);
      if (!entry) {
        const sprite = spriteFor(item);
        sprite.x = sx;
        sprite.y = sy3d;
        sprite.rotation = ((item.rotation || 0) * Math.PI) / 180;
        sprite.alpha = 0.98;
        // aplica escala do usu√°rio
        const base =
          item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
        const scl = Number(item.scale || 1.0);
        if (sprite.hsSpr) sprite.hsSpr.scale.set(base * scl);
        sprite.on("pointerdown", (e) => {
          // Evita que o clique no sprite limpe a sele√ß√£o via handler global
          SCENE.justClickedSprite = true;
          setTimeout(() => (SCENE.justClickedSprite = false), 0);
          startDrag(item.id, e);
        });
        sprite.on("pointertap", () => selectItem(item.id));
        SCENE.world.addChild(sprite);
        entry = { item: { ...item }, sprite };
        SCENE.items.set(item.id, entry);
      } else {
        entry.item = { ...item };
        entry.sprite.x = sx;
        entry.sprite.y = sy3d;
        entry.sprite.rotation = ((item.rotation || 0) * Math.PI) / 180;
        const base =
          item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
        const scl = Number(item.scale || 1.0);
        if (entry.sprite.hsSpr) entry.sprite.hsSpr.scale.set(base * scl);
      }
      sortByDepth();
    }

    function sortByDepth() {
      const arr = Array.from(SCENE.items.values());
      arr.sort((a, b) => {
        const la = Number(a.item.layer || 0);
        const lb = Number(b.item.layer || 0);
        if (la !== lb) return la - lb; // layer menor fica atr√°s
        return a.sprite.y - b.sprite.y; // empate: usa profundidade isom√©trica
      });
      arr.forEach((e, i) => (e.sprite.zIndex = 100 + i));
      if (SCENE.world) SCENE.world.sortChildren();
    }

    let DRAG = null;
    function startDrag(id, e) {
      selectItem(id);
      DRAG = { id };
      const up = () => {
        if (!DRAG) return;
        finishDrag();
        window.removeEventListener("pointerup", up);
        window.removeEventListener("pointermove", move);
      };
      const move = (ev) => dragMove(ev);
      window.addEventListener("pointerup", up);
      window.addEventListener("pointermove", move);
    }
    function dragMove(ev) {
      if (!DRAG) return;
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) return;
      const container = document.getElementById("corner-canvas");
      const rect = container.getBoundingClientRect();
      const px = ev.clientX - rect.left;
      const py = ev.clientY - rect.top;
      // converte para coordenadas do mundo (compensa zoom/pan)
      const ptLocal = SCENE.world
        ? SCENE.world.toLocal(new PIXI.Point(px, py))
        : new PIXI.Point(px, py);
      let best = { d: Infinity, gx: 0, gy: 0, sx: 0, sy: 0 };
      for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
        for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const sy3d = sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
          const dx = sx - ptLocal.x,
            dy = sy3d - ptLocal.y;
          const d = dx * dx + dy * dy;
          if (d < best.d) best = { d, gx: i, gy: j, sx, sy: sy3d };
        }
      }
      const size = HS_ISO.sizes[entry.item.item_key] || { w: 1, h: 1 };
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const gx = clamp(best.gx, 0, HS_ISO.gridN - size.w);
      const gy = clamp(best.gy, 0, HS_ISO.gridN - size.h);
      const p = HS_ISO.projectWorld(gx, gy);
      const sy3d = p.sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
      entry.sprite.x = p.sx;
      entry.sprite.y = sy3d;
      DRAG.gx = gx;
      DRAG.gy = gy;
      if (SCENE.selectedId === DRAG.id) updateOverlayPosition(DRAG.id);
    }
    async function finishDrag() {
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) {
        DRAG = null;
        return;
      }
      const xPct = gridToPct(DRAG.gx);
      const yPct = gridToPct(DRAG.gy);
      const ok = await savePosition(DRAG.id, xPct, yPct);
      if (ok) {
        entry.item.x = xPct;
        entry.item.y = yPct;
      }
      sortByDepth();
      DRAG = null;
    }

    function selectItem(id) {
      SCENE.selectedId = id;
      SCENE.items.forEach(({ sprite }, key) => {
        sprite.scale.set(key === id ? 1.06 : 1.0);
      });
      updateOverlayPosition(id);
      bindOverlayActions(id);
    }

    function updateOverlayPosition(id) {
      const entry = SCENE.items.get(id);
      const overlay = document.getElementById("corner-overlay");
      const container = document.getElementById("corner-canvas");
      if (!entry || !overlay || !container) return;
      overlay.classList.remove("hidden");
      const gap = 8;
      // posi√ß√£o global do sprite (considera zoom/pan)
      const gp = entry.sprite.getGlobalPosition();
      const px = Math.round(gp.x);
      const py = Math.round(gp.y);
      // remover transform para medir corretamente
      overlay.style.transform = "none";
      // for√ßa c√°lculo de dimens√µes
      const w = overlay.offsetWidth || 160;
      const h = overlay.offsetHeight || 32;
      const cw = container.clientWidth || 0;
      const ch = container.clientHeight || 0;
      // preferir acima
      let left = Math.round(px - w / 2);
      let top = Math.round(py - (h + gap));
      // se n√£o couber acima, coloca abaixo
      if (top < 4) top = Math.round(py + gap);
      // clamp para dentro do canvas
      const minX = 4;
      const minY = 4;
      const maxX = Math.max(minX, cw - w - 4);
      const maxY = Math.max(minY, ch - h - 4);
      left = Math.max(minX, Math.min(maxX, left));
      top = Math.max(minY, Math.min(maxY, top));
      overlay.style.left = left + "px";
      overlay.style.top = top + "px";
      updateOverlayRotationDisplay(id);
      updateOverlayScaleDisplay(id);
    }

    function updateOverlayRotationDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const span = document.getElementById("overlay-rot");
        if (!entry || !span) return;
        const rot = Math.round(entry.item.rotation || 0) % 360;
        span.textContent = `${rot}¬∞`;
      } catch (_) {}
    }

    function updateOverlayScaleDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const input = document.getElementById("overlay-scale");
        if (!entry || !input) return;
        input.value = Number(entry.item.scale || 1.0).toFixed(2);
      } catch (_) {}
    }

    function bindOverlayActions(id) {
      const overlay = document.getElementById("corner-overlay");
      if (!overlay) return;
      const idSel = id;
      const btnDel = document.getElementById("btn-delete");
      const btnLU = document.getElementById("btn-layer-up");
      const btnLD = document.getElementById("btn-layer-down");
      const btnLT = document.getElementById("btn-layer-top");
      const btnLB = document.getElementById("btn-layer-bottom");
      if (btnDel)
        btnDel.onclick = async (e) => {
          e.stopPropagation();
          await deleteItem(idSel);
          overlay.classList.add("hidden");
        };
      // bot√µes de rota√ß√£o e altura removidos do overlay

      function layerBounds() {
        let min = 0,
          max = 0;
        SCENE.items.forEach(({ item }) => {
          const l = Number(item.layer || 0);
          if (l < min) min = l;
          if (l > max) max = l;
        });
        return { min, max };
      }
      if (btnLU)
        btnLU.onclick = async (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            const { max } = layerBounds();
            await saveLayer(idSel, max + 1);
          } else {
            await saveStack(idSel, +1);
          }
        };
      if (btnLD)
        btnLD.onclick = async (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            const { min } = layerBounds();
            await saveLayer(idSel, min - 1);
          } else {
            await saveStack(idSel, -1);
          }
        };
      if (btnLT)
        btnLT.onclick = async (e) => {
          e.stopPropagation();
          const { max } = layerBounds();
          await saveLayer(idSel, max + 1);
        };
      if (btnLB)
        btnLB.onclick = async (e) => {
          e.stopPropagation();
          const { min } = layerBounds();
          await saveLayer(idSel, min - 1);
        };

      const inputScale = document.getElementById("overlay-scale");
      const btnInc = document.getElementById("btn-scale-inc");
      const btnDec = document.getElementById("btn-scale-dec");
      async function setScale(val) {
        const scl = Math.max(0.25, Math.min(2.0, Number(val) || 1.0));
        await saveScale(idSel, scl);
        updateOverlayScaleDisplay(idSel);
      }
      if (inputScale) {
        inputScale.onchange = async (e) => {
          e.stopPropagation();
          await setScale(inputScale.value);
        };
      }
      if (btnInc)
        btnInc.onclick = async (e) => {
          e.stopPropagation();
          const v = Number((Number(inputScale.value || 1) + 0.05).toFixed(2));
          await setScale(v);
        };
      if (btnDec)
        btnDec.onclick = async (e) => {
          e.stopPropagation();
          const v = Number((Number(inputScale.value || 1) - 0.05).toFixed(2));
          await setScale(v);
        };
    }

    function clearSelection() {
      SCENE.selectedId = null;
      const overlay = document.getElementById("corner-overlay");
      if (overlay) overlay.classList.add("hidden");
      SCENE.items.forEach(({ sprite }) => sprite.scale.set(1.0));
    }

    function bindOutsideClicks() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      const onCanvasDown = (ev) => {
        if (SCENE.justClickedSprite) return;
        // n√£o limpar sele√ß√£o quando iniciar pan (bot√£o do meio ou Space+esquerdo)
        if (ev && (ev.button === 1 || (ev.button === 0 && SCENE.spaceDown)))
          return;
        clearSelection();
      };
      container.addEventListener("pointerdown", onCanvasDown);

      const onDocDown = (ev) => {
        const overlay = document.getElementById("corner-overlay");
        if (overlay && overlay.contains(ev.target)) return;
        const insideCanvas =
          ev.target.closest && ev.target.closest("#corner-canvas");
        if (!insideCanvas) clearSelection();
      };
      document.addEventListener("pointerdown", onDocDown);
      BOUND.click = { onCanvasDown, onDocDown };
    }

    // Pan do canvas (bot√£o do meio ou Space + arrastar com esquerdo)
    function bindPan() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      const onDown = (ev) => {
        const wantPan = ev.button === 1 || (ev.button === 0 && SCENE.spaceDown);
        if (!wantPan) return;
        ev.preventDefault();
        SCENE.pan = SCENE.pan || {};
        SCENE.pan.active = true;
        SCENE.pan.startX = ev.clientX;
        SCENE.pan.startY = ev.clientY;
        SCENE.pan.worldX = SCENE.world ? SCENE.world.position.x : 0;
        SCENE.pan.worldY = SCENE.world ? SCENE.world.position.y : 0;
        container.style.cursor = "grabbing";
        const onMove = (e) => {
          if (!SCENE.pan.active || !SCENE.world) return;
          const dx = e.clientX - SCENE.pan.startX;
          const dy = e.clientY - SCENE.pan.startY;
          SCENE.world.position.set(
            SCENE.pan.worldX + dx,
            SCENE.pan.worldY + dy
          );
          if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
        };
        const onUp = () => {
          SCENE.pan.active = false;
          // se Space ainda est√° segurado, volta para 'grab'; sen√£o limpa
          container.style.cursor = SCENE.spaceDown ? "grab" : "";
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
        };
        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onUp);
      };
      container.addEventListener("pointerdown", onDown);
      BOUND.pan = { onDown };
    }

    async function saveStack(id, dir) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/stack`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dir }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function savePosition(id, x, y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/position`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ x, y }),
        });
        return res.ok;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveNudge(id, dx = 0, dy = 0, drot = 0) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/nudge`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dx, dy, drot }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveHeight(id, dz) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/height`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dz }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function saveScale(id, scale) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/scale`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ scale }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveLayer(id, layer) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/layer`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ layer }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function deleteItem(id) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/delete`, {
          method: "POST",
          headers: { "X-CSRF-Token": CSRF, "HX-Request": "true" },
        });
        if (!res.ok) return false;
        removeSprite(id);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    function htmlToNode(html) {
      const t = document.createElement("div");
      t.innerHTML = html.trim();
      return t.firstElementChild;
    }
    function removeSprite(id) {
      const e = SCENE.items.get(id);
      if (!e) return;
      e.sprite.destroy({ children: true });
      SCENE.items.delete(id);
    }

    // resize handler
    function bindResize() {
      BOUND.resize = () => {
        if (!PIXI_APP) return;
        const container = document.getElementById("corner-canvas");
        if (container) HS_ISO.computeOrigin(container);
        drawFloor(SCENE.world);
        SCENE.items.forEach(({ item }) => addOrUpdateItem(item));
        if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
      };
      window.addEventListener("resize", BOUND.resize);
    }

    // Integra√ß√£o com htmx (listener removido no destroy)
    function bindHtmx() {
      BOUND.htmx = (e) => {
        const target = e && e.detail && e.detail.target;
        if (target && target.id === "corner-outbox") {
          const node = target.querySelector(".corner-item");
          if (node) {
            const item = domItemToData(node);
            try {
              window.__cornerItems = Array.isArray(window.__cornerItems)
                ? window.__cornerItems
                : [];
              window.__cornerItems.push(item);
            } catch (_) {}
            addOrUpdateItem(item);
            selectItem(item.id);
            target.innerHTML = "";
          }
        }
      };
      document.addEventListener("htmx:afterSwap", BOUND.htmx);
    }

    // Teclado
    async function onKey(ev) {
      // n√£o interferir quando digitando em inputs
      const t = ev.target;
      const tag = (t && t.tagName) || "";
      if (tag === "INPUT" || tag === "TEXTAREA" || (t && t.isContentEditable))
        return;
      if (!SCENE.selectedId) return;
      const id = SCENE.selectedId;
      const entry = SCENE.items.get(id);
      if (!entry) return;
      // Removido: movimenta√ß√£o por setas
      if (ev.key.toLowerCase() === "q") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, -15);
        updateOverlayRotationDisplay(id);
      } else if (ev.key.toLowerCase() === "e") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, 15);
        updateOverlayRotationDisplay(id);
      } else if (
        (ev.ctrlKey || ev.metaKey) &&
        (ev.key === "=" || ev.key === "+")
      ) {
        // Prioriza escala com Ctrl/Cmd +
        ev.preventDefault();
        const cur = Number(entry.item.scale || 1.0);
        await saveScale(id, Math.min(2.0, Number((cur + 0.05).toFixed(2))));
      } else if ((ev.ctrlKey || ev.metaKey) && ev.key === "-") {
        // Prioriza escala com Ctrl/Cmd -
        ev.preventDefault();
        const cur = Number(entry.item.scale || 1.0);
        await saveScale(id, Math.max(0.25, Number((cur - 0.05).toFixed(2))));
      } else if (ev.key === "PageUp" || ev.key === "+") {
        ev.preventDefault();
        await saveHeight(id, 1);
      } else if (ev.key === "PageDown" || ev.key === "-") {
        ev.preventDefault();
        await saveHeight(id, -1);
      } else if (ev.key === "]") {
        ev.preventDefault();
        await saveStack(id, +1);
      } else if (ev.key === "[") {
        ev.preventDefault();
        await saveStack(id, -1);
      } else if (ev.key === "Delete") {
        ev.preventDefault();
        await deleteItem(id);
      }
    }

    // Roda do mouse (com Ctrl ou Alt) para girar item selecionado
    function bindWheelRotate() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      container.addEventListener(
        "wheel",
        async (ev) => {
          // Zoom do canvas quando sem modificadores
          if (!ev.ctrlKey && !ev.altKey && !ev.shiftKey) {
            ev.preventDefault();
            const rect = container.getBoundingClientRect();
            const mx = ev.clientX - rect.left;
            const my = ev.clientY - rect.top;
            const dir = ev.deltaY < 0 ? 1 : -1; // roda pra cima = zoom in
            const next = Math.max(0.6, Math.min(2.0, SCENE.zoom + dir * 0.1));
            if (SCENE.world) {
              // ancora o zoom no cursor
              const local = SCENE.world.toLocal(new PIXI.Point(mx, my));
              SCENE.world.pivot.set(local.x, local.y);
              SCENE.world.position.set(mx, my);
              SCENE.world.scale.set(next);
              SCENE.zoom = next;
              if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
            }
            return;
          }
          if (!SCENE.selectedId) return;
          // Shift: escala; Ctrl/Alt: rota√ß√£o
          if (ev.shiftKey) {
            ev.preventDefault();
            const id = SCENE.selectedId;
            const entry = SCENE.items.get(id);
            const cur = Number(entry?.item?.scale || 1.0);
            const next = ev.deltaY > 0 ? cur - 0.05 : cur + 0.05;
            await saveScale(
              id,
              Math.max(0.25, Math.min(2.0, Number(next.toFixed(2))))
            );
            updateOverlayScaleDisplay(id);
            return;
          }
          if (!ev.ctrlKey && !ev.altKey) return; // somente com modificador
          ev.preventDefault();
          const id = SCENE.selectedId;
          const dir = ev.deltaY > 0 ? 15 : -15;
          await saveNudge(id, 0, 0, dir);
          updateOverlayRotationDisplay(id);
        },
        { passive: false }
      );
    }

    // Expor e inicializar
    function destroy() {
      try {
        if (BOUND.keydown) window.removeEventListener("keydown", BOUND.keydown);
        if (BOUND.keyup) window.removeEventListener("keyup", BOUND.keyup);
        if (BOUND.resize) window.removeEventListener("resize", BOUND.resize);
        if (BOUND.htmx)
          document.removeEventListener("htmx:afterSwap", BOUND.htmx);
        if (BOUND.click) {
          const container = document.getElementById("corner-canvas");
          if (container && BOUND.click.onCanvasDown)
            container.removeEventListener(
              "pointerdown",
              BOUND.click.onCanvasDown
            );
          if (BOUND.click.onDocDown)
            document.removeEventListener("pointerdown", BOUND.click.onDocDown);
        }
        if (BOUND.pan) {
          const container = document.getElementById("corner-canvas");
          if (container && BOUND.pan.onDown)
            container.removeEventListener("pointerdown", BOUND.pan.onDown);
        }
      } catch (_) {}
      try {
        const container = document.getElementById("corner-canvas");
        if (PIXI_APP) {
          PIXI_APP.destroy(true, {
            children: true,
            texture: true,
            baseTexture: true,
          });
          if (container) container.innerHTML = "";
        }
      } catch (_) {}
      PIXI_APP = null;
    }

    window.__CornerInstance = { destroy };
    // init now (scripts de p√°ginas htmx executam ap√≥s inser√ß√£o no DOM)
    ensurePixi();
    bindResize();
    bindHtmx();
    bindWheelRotate();
    bindPan();
    bindOutsideClicks();

    // filtro de invent√°rio
    const search = document.getElementById("inventory-search");
    const list = document.getElementById("inventory-list");
    if (search && list) {
      const onInput = () => {
        const q = (search.value || "").trim().toLowerCase();
        list.querySelectorAll("li").forEach((li) => {
          const txt = (li.textContent || "").toLowerCase();
          li.style.display = !q || txt.includes(q) ? "" : "none";
        });
      };
      search.addEventListener("input", onInput);
    }
  })();
</script>
