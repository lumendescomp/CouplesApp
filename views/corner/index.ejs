<div class="space-y-6">
  <header class="flex items-center justify-between">
    <h1 class="page-title text-2xl font-semibold text-violet-100">Nosso cantinho</h1>
  </header>

  <div class="grid grid-cols-[1fr_280px] gap-6">
    <!-- Canvas do cantinho -->
    <section
      class="relative rounded-xl border border-violet-700/40 bg-white/5 overflow-hidden h-[420px]"
    >
      <div id="corner-canvas" class="absolute inset-0"></div>
      <!-- Toolbar de Zoom -->
      <div
        class="absolute top-2 left-2 z-30 flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md pointer-events-none"
      >
        <button
          id="btn-zoom-out"
          class="px-2 py-1 hover:bg-white/10 rounded pointer-events-auto"
          title="Zoom out"
        >
          ‚àí
        </button>
        <button
          id="btn-zoom-reset"
          class="px-2 py-1 hover:bg-white/10 rounded text-xs pointer-events-auto"
          title="Resetar para 100%"
        >
          <span id="zoom-label">100%</span>
        </button>
        <button
          id="btn-zoom-in"
          class="px-2 py-1 hover:bg-white/10 rounded pointer-events-auto"
          title="Zoom in"
        >
          +
        </button>
        <span class="mx-1 text-white/30">|</span>
        <div
          class="flex items-center gap-1 pointer-events-auto"
          title="Cores gerais"
        >
          <label for="color-canvas" class="text-[10px] text-violet-200/80"
            >Canvas</label
          >
          <input
            id="color-canvas"
            type="color"
            class="w-5 h-5 p-0 bg-transparent border-0 cursor-pointer"
            value="#0b0b0b"
          />
          <label for="color-floor" class="ml-2 text-[10px] text-violet-200/80"
            >Ch√£o</label
          >
          <input
            id="color-floor"
            type="color"
            class="w-5 h-5 p-0 bg-transparent border-0 cursor-pointer"
            value="#7c3aed"
          />
          <label for="color-wall" class="ml-2 text-[10px] text-violet-200/80"
            >Borda</label
          >
          <input
            id="color-wall"
            type="color"
            class="w-5 h-5 p-0 bg-transparent border-0 cursor-pointer"
            value="#6b21a8"
          />
        </div>
      </div>
      <!-- Overlay de a√ß√µes do item selecionado -->
      <div
        id="corner-overlay"
        class="absolute z-20 hidden"
        style="pointer-events: auto"
      >
        <div
          class="flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md"
        >
          <button
            id="btn-layer-down"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Enviar para tr√°s"
          >
            ‚§∫
          </button>
          <button
            id="btn-layer-up"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Trazer para frente"
          >
            ‚§ª
          </button>
          <button
            id="btn-layer-bottom"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Enviar para o fundo"
          >
            ‚§ì
          </button>
          <button
            id="btn-layer-top"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Trazer para o topo"
          >
            ‚§í
          </button>
          <span class="mx-1 text-white/30">|</span>
          <label for="overlay-scale" class="sr-only">Escala</label>
          <input
            id="overlay-scale"
            type="number"
            step="0.05"
            min="0.25"
            max="2"
            value="1.0"
            class="w-20 bg-white/10 border border-violet-700/40 rounded px-1 py-0.5 text-violet-100 text-xs"
            title="Escala (0.25‚Äî2.0)"
          />
          <button
            id="btn-scale-dec"
            class="px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Escala -0.05"
          >
            ‚àí
          </button>
          <button
            id="btn-scale-inc"
            class="px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Escala +0.05"
          >
            +
          </button>
          <span class="mx-1 text-white/30">|</span>
          <!-- Stretch (n√£o-uniforme) -->
          <label for="overlay-stretch-x" class="text-[10px] text-violet-200/80"
            >Larg</label
          >
          <input
            id="overlay-stretch-x"
            type="number"
            step="0.05"
            min="0.25"
            max="3"
            value="1.0"
            class="w-16 bg-white/10 border border-violet-700/40 rounded px-1 py-0.5 text-violet-100 text-xs"
            title="Esticar largura (0.25‚Äî3.0)"
          />
          <label
            for="overlay-stretch-y"
            class="ml-1 text-[10px] text-violet-200/80"
            >Alt</label
          >
          <input
            id="overlay-stretch-y"
            type="number"
            step="0.05"
            min="0.25"
            max="3"
            value="1.0"
            class="w-16 bg-white/10 border border-violet-700/40 rounded px-1 py-0.5 text-violet-100 text-xs"
            title="Esticar altura (0.25‚Äî3.0)"
          />
          <span class="mx-1 text-white/30">|</span>
          <span
            id="overlay-color-wrap"
            class="inline-flex items-center gap-1 hidden"
            title="Cor do piso/parede"
          >
            <label for="overlay-color" class="text-[10px] text-violet-200/80"
              >Cor</label
            >
            <input
              id="overlay-color"
              type="color"
              class="w-6 h-6 p-0 bg-transparent border-0 cursor-pointer"
              value="#6b21a8"
            />
            <span class="mx-1 text-white/30">|</span>
          </span>
          <button
            id="btn-delete"
            class="px-2 py-1 bg-rose-600/80 hover:bg-rose-600 text-white rounded"
            title="Remover"
          >
            üóë
          </button>
          <span class="mx-1 text-white/30">|</span>
          <button
            id="btn-help"
            class="ml-1 px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Ajuda: atalhos de flip, tilt e nudge"
            type="button"
          >
            ‚ùî
          </button>
          <span class="mx-1 text-white/30">|</span>
        </div>
      </div>
    </section>

    <!-- Modal de Ajuda -->
    <div
      id="help-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center"
      aria-hidden="true"
    >
      <div class="absolute inset-0 bg-black/60"></div>
      <div
        class="relative w-[360px] max-w-[90vw] rounded-xl border border-violet-700/40 bg-[#120a1b] text-violet-100 shadow-xl p-4"
        role="dialog"
        aria-modal="true"
        aria-labelledby="help-title"
      >
        <div class="flex items-center justify-between mb-2">
          <h3 id="help-title" class="text-lg font-semibold">Ajuda r√°pida</h3>
          <button
            id="help-close"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Fechar"
          >
            ‚úï
          </button>
        </div>
        <div class="space-y-3 text-sm leading-relaxed">
          <div>
            <div class="font-medium text-violet-200">
              Girar (nudge de rota√ß√£o)
            </div>
            <p class="text-violet-300/90">
              Q/E gira em passos de 15¬∞. Com Ctrl ou Alt + roda do mouse voc√™
              tamb√©m gira.
            </p>
          </div>
          <div>
            <div class="font-medium text-violet-200">Tilt (inclinar)</div>
            <p class="text-violet-300/90">
              T/G ajusta Tilt X; Y/H ajusta Tilt Y. Pequenos passos para
              controlar a inclina√ß√£o.
            </p>
          </div>
          <div>
            <div class="font-medium text-violet-200">Flip (espelhar)</div>
            <p class="text-violet-300/90">
              F faz Flip horizontal; V faz Flip vertical.
            </p>
          </div>
          <div>
            <div class="font-medium text-violet-200">Outros</div>
            <ul class="list-disc list-inside text-violet-300/90">
              <li>Shift + roda do mouse: escala</li>
              <li>Ctrl/Cmd + + ou - : escala fina</li>
              <li>Delete: remover item selecionado</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Invent√°rio -->
    <aside
      class="rounded-xl border border-violet-700/40 bg-white/5 p-3 max-h-[420px] overflow-y-auto overflow-x-hidden inventory-scroll"
    >
      <h2 class="text-lg text-violet-100 mb-3">Invent√°rio</h2>
      <div class="mb-3">
        <input
          id="inventory-search"
          type="text"
          class="w-full bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100 placeholder-violet-300/60 focus:outline-none focus:ring-2 focus:ring-violet-500/50"
          placeholder="Buscar item..."
          autocomplete="off"
        />
      </div>
      <div
        id="inventory-groups"
        class="space-y-2 text-violet-200 text-sm"
      ></div>
      <p class="mt-4 text-xs text-violet-300/80">
        Dica: clique em um item para selecion√°-lo; d√™ duplo clique para
        adicionar imediatamente.
      </p>
    </aside>
  </div>
</div>

<!-- Dados iniciais para o Pixi (evita EJS direto no JS) -->
<script type="application/json" id="corner-items-data">
  <%- JSON.stringify(items || []) %>
</script>
<script type="application/json" id="corner-colors-data">
  <%- JSON.stringify({
    canvas: (couple && couple.corner_canvas_color) || null,
    floor: (couple && couple.corner_floor_color) || null,
    wall: (couple && couple.corner_wall_color) || null,
  }) %>
</script>

<style>
  /* Scrollbar custom para o invent√°rio */
  .inventory-scroll {
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: #7c3aed #1f1033; /* thumb track */
  }
  .inventory-scroll::-webkit-scrollbar {
    width: 10px;
  }
  .inventory-scroll::-webkit-scrollbar-track {
    background: linear-gradient(
      180deg,
      rgba(124, 58, 237, 0.15),
      rgba(17, 10, 27, 0.2)
    );
    border-radius: 8px;
  }
  .inventory-scroll::-webkit-scrollbar-thumb {
    background-color: rgba(124, 58, 237, 0.7);
    border-radius: 8px;
    border: 2px solid rgba(17, 10, 27, 0.6);
  }
  .inventory-scroll::-webkit-scrollbar-thumb:hover {
    background-color: rgba(167, 139, 250, 0.9);
  }
  /* Melhorar in√©rcia no macOS/iOS */
  .inventory-scroll {
    -webkit-overflow-scrolling: touch;
  }
</style>

<script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
<script>
  // Aguarda o carregamento do PIXI antes de inicializar a p√°gina
  function waitForPixi() {
    return new Promise((resolve, reject) => {
      // Verifica se PIXI j√° est√° dispon√≠vel e funcional
      if (typeof PIXI !== "undefined" && PIXI.Application) {
        console.info("[corner] PIXI j√° est√° dispon√≠vel");
        resolve();
        return;
      }

      console.info("[corner] Aguardando carregamento do PIXI...");
      let attempts = 0;
      const maxAttempts = 100; // 5 segundos (50ms * 100)

      const checkPixi = setInterval(() => {
        attempts++;

        if (typeof PIXI !== "undefined" && PIXI.Application) {
          clearInterval(checkPixi);
          console.info("[corner] PIXI carregado com sucesso!");
          resolve();
        } else if (attempts >= maxAttempts) {
          clearInterval(checkPixi);
          console.error(
            "[corner] Timeout ao aguardar PIXI - biblioteca n√£o carregou"
          );
          reject(new Error("PIXI n√£o carregou"));
        }
      }, 50);
    });
  }

  // Dados iniciais vindos do servidor (via tag JSON)
  (function () {
    try {
      const el = document.getElementById("corner-items-data");
      window.__cornerItems = el ? JSON.parse(el.textContent || "[]") : [];
    } catch {
      window.__cornerItems = [];
    }
    try {
      const el = document.getElementById("corner-colors-data");
      window.__cornerColors = el ? JSON.parse(el.textContent || "{}") : {};
    } catch {
      window.__cornerColors = {};
    }
  })();
  // Isolar todo o c√≥digo da p√°gina em um controller para evitar redeclara√ß√µes em navega√ß√£o htmx
  (async function CornerPage() {
    try {
      // Aguarda PIXI estar dispon√≠vel
      await waitForPixi();
    } catch (error) {
      console.error("[corner] Erro ao carregar PIXI:", error);
      const container = document.getElementById("corner-canvas");
      if (container) {
        container.innerHTML = `
          <div class="flex items-center justify-center h-full">
            <div class="text-center p-6">
              <div class="text-red-400 text-lg mb-2">‚ö†Ô∏è Erro ao carregar o cantinho</div>
              <div class="text-violet-300 text-sm">A biblioteca gr√°fica n√£o carregou corretamente.</div>
              <button 
                onclick="window.location.reload()" 
                class="mt-4 px-4 py-2 bg-violet-600 hover:bg-violet-700 text-white rounded-lg"
              >
                Recarregar p√°gina
              </button>
            </div>
          </div>
        `;
      }
      return;
    }

    // Se j√° existe uma inst√¢ncia anterior, destr√≥i antes de inicializar
    if (
      window.__CornerInstance &&
      typeof window.__CornerInstance.destroy === "function"
    ) {
      try {
        window.__CornerInstance.destroy();
      } catch (_) {}
    }

    // Proje√ß√£o isom√©trica simples (escopo local)
    const HS_ISO = {
      gridN: 20,
      tileW: 72,
      tileH: 36,
      // origem fixa no espa√ßo do "world" (n√£o depende do container ap√≥s inicializar)
      originX: 0,
      originY: 0,
      // Nota: o antigo mapa de tamanhos (sizes) foi removido por n√£o ser usado
      // Define a origem no espa√ßo do world, centralizando a grade inicialmente
      computeOrigin(container) {
        const { tileH, gridN } = this;
        const cw = container.clientWidth || 800;
        const ch = container.clientHeight || 420;
        const gridPixelH = gridN * tileH;
        this.originX = cw / 2;
        // encostar a primeira fileira no topo, sem cortar o losango
        this.originY = this.tileH / 2;
      },
      // Projeta coordenadas de grade para coordenadas locais do world
      projectWorld(gx, gy) {
        const { tileW, tileH, originX, originY } = this;
        const sx = originX + (gx - gy) * (tileW / 2);
        const sy = originY + (gx + gy) * (tileH / 2);
        return { sx, sy };
      },
    };

    // ===== Implementa√ß√£o Pixi =====
    // Usar vari√°vel global para evitar m√∫ltiplos contextos WebGL
    if (!window.__PIXI_APP_GLOBAL) {
      window.__PIXI_APP_GLOBAL = null;
    }
    let PIXI_APP = window.__PIXI_APP_GLOBAL;

    const SCENE = {
      items: new Map(),
      selectedId: null,
      world: null,
      zoom: 1,
      spaceDown: false,
      pan: { active: false },
      floor: null,
      walls: null,
      ghost: null,
      colorOverrides: new Map(), // id -> color (number, 0xRRGGBB)
      // cores globais
      canvasColor: 0x0b0b0b,
      floorColor: 0x7c3aed,
      wallColor: 0x6b21a8,
      // c√≥pias persistidas para restaura√ß√£o ap√≥s preview
      savedCanvasColor: null,
      savedFloorColor: null,
      savedWallColor: null,
    };
    // inicializa cores globais a partir do backend (se houver)
    try {
      if (window.__cornerColors) {
        const c = window.__cornerColors;
        if (c.canvas != null) SCENE.canvasColor = Number(c.canvas) >>> 0;
        if (c.floor != null) SCENE.floorColor = Number(c.floor) >>> 0;
        if (c.wall != null) SCENE.wallColor = Number(c.wall) >>> 0;
      }
    } catch {}
    // inicializa saved* com os valores atuais
    SCENE.savedCanvasColor = SCENE.canvasColor;
    SCENE.savedFloorColor = SCENE.floorColor;
    SCENE.savedWallColor = SCENE.wallColor;

    // Altura visual padr√£o das paredes (unificada entre bordas e itens "parede")
    function getWallHeight() {
      return Math.round(HS_ISO.tileH * 4);
    }
    // estado de drag global para invent√°rio -> canvas
    const DRAG_STATE = { key: null };
    const BOUND = {
      resize: null,
      keydown: null,
      keyup: null,
      click: null,
      pan: null,
    };

    function pctToGrid(p) {
      // Converte porcentagem para √≠ndice de grade com resolu√ß√£o de 0.25
      const step = 100 / (HS_ISO.gridN - 1);
      const gi = (Number(p) || 0) / step; // pode ser fracion√°rio
      // arredonda para o m√∫ltiplo de 0.25 mais pr√≥ximo
      const g025 = Math.round(gi * 4) / 4;
      return Math.max(0, Math.min(HS_ISO.gridN - 1, g025));
    }
    function gridToPct(g) {
      // Converte √≠ndice de grade (pode ter .5) para porcentagem sem arredondar
      const step = 100 / (HS_ISO.gridN - 1);
      const val = (Number(g) || 0) * step;
      // limita a duas casas decimais para estabilidade de rede/render
      return Math.max(0, Math.min(100, Number(val.toFixed(2))));
    }
    // Alinha paredes √†s dire√ß√µes da malha isom√©trica
    function quantizeWallRotation(deg) {
      const a = ((Number(deg) % 360) + 360) % 360;
      // dire√ß√µes principais da grade: 26.565¬∞, 153.435¬∞, 206.565¬∞, 333.435¬∞
      const opts = [26.565, 153.435, 206.565, 333.435];
      let best = opts[0];
      let min = Infinity;
      for (const o of opts) {
        const d = Math.min(Math.abs(a - o), 360 - Math.abs(a - o));
        if (d < min) {
          min = d;
          best = o;
        }
      }
      return best;
    }
    function domItemToData(node) {
      return {
        id: Number(node.getAttribute("data-id")),
        item_key: node.getAttribute("data-key") || "unknown",
        x: Number(node.getAttribute("data-x") || 50),
        y: Number(node.getAttribute("data-y") || 50),
        z: Number(node.getAttribute("data-z") || 0),
        rotation: Number(node.getAttribute("data-rot") || 0),
        tilt_x: Number(node.getAttribute("data-tilt-x") || 0),
        tilt_y: Number(node.getAttribute("data-tilt-y") || 0),
        flip_x: Number(node.getAttribute("data-flip-x") || 0) ? 1 : 0,
        flip_y: Number(node.getAttribute("data-flip-y") || 0) ? 1 : 0,
        scale: Number(node.getAttribute("data-scale") || 1.0),
        layer: Number(node.getAttribute("data-layer") || 0),
        color: (function () {
          const v = node.getAttribute("data-color");
          if (v == null || v === "" || v === undefined) return null;
          const n = Number(v);
          return Number.isFinite(n) ? n : null;
        })(),
        stretch_x: (function () {
          const v = node.getAttribute("data-stretch-x");
          const n = Number(v);
          return Number.isFinite(n) ? n : 1.0;
        })(),
        stretch_y: (function () {
          const v = node.getAttribute("data-stretch-y");
          const n = Number(v);
          return Number.isFinite(n) ? n : 1.0;
        })(),
      };
    }

    async function loadAtlasIfAny() {
      // Sempre cria um novo objeto de atlas limpo
      const ATLAS = { ready: false, frames: {} };

      try {
        const resMan = await fetch("/public/assets/atlas/manifest.json", {
          cache: "no-store",
        });
        if (resMan.ok) {
          const man = await resMan.json();
          const exts = /\.(png|jpg|jpeg|webp|gif|svg)$/i;
          const normUrl = (u) => {
            if (typeof u !== "string") return null;
            let s = u.replace(/^\.\/?/, "");
            s = s.replace(/^public\//, "");
            const fname = s.split("/").pop();
            if (!fname || !exts.test(fname)) return null;
            return `/public/assets/atlas/${fname}`;
          };
          const frames = {};
          if (man && man.images && typeof man.images === "object") {
            for (const [k, u] of Object.entries(man.images)) {
              const url = normUrl(u);
              if (!url) continue;
              try {
                // For√ßa cria√ß√£o de nova textura (n√£o usa cache)
                frames[`${k}`] = PIXI.Texture.from(url, {
                  resourceOptions: { autoLoad: true },
                });
              } catch {}
              try {
                frames[`${k}.png`] = frames[`${k}`];
              } catch {}
            }
          } else if (man && typeof man === "object") {
            for (const [k, u] of Object.entries(man)) {
              if (typeof u !== "string") continue;
              const url = normUrl(u);
              if (!url) continue;
              try {
                // For√ßa cria√ß√£o de nova textura (n√£o usa cache)
                frames[`${k}`] = PIXI.Texture.from(url, {
                  resourceOptions: { autoLoad: true },
                });
              } catch {}
              try {
                frames[`${k}.png`] = frames[`${k}`];
              } catch {}
            }
          }
          if (Object.keys(frames).length) {
            ATLAS.ready = true;
            ATLAS.frames = frames;
            console.info(
              "[corner] Atlas carregado com",
              Object.keys(frames).length,
              "texturas"
            );
            return ATLAS;
          }
        }
      } catch (e) {
        console.error("[corner] Erro ao carregar atlas:", e);
      }

      return ATLAS;
    }

    async function ensurePixi(force = false) {
      const container = document.getElementById("corner-canvas");
      if (!container) return;

      // Verifica se PIXI est√° dispon√≠vel
      if (typeof PIXI === "undefined") {
        console.error("[corner] PIXI n√£o est√° carregado ainda");
        return;
      }

      // Recupera refer√™ncia global para evitar m√∫ltiplos contextos
      PIXI_APP = window.__PIXI_APP_GLOBAL;

      // Se j√° existe inst√¢ncia, verifica se precisa recriar
      if (PIXI_APP && !force) {
        // Verifica se o canvas ainda est√° no DOM
        const canvasStillInDOM =
          PIXI_APP.view && document.body.contains(PIXI_APP.view);
        if (!canvasStillInDOM) {
          console.warn("[corner] Detectado canvas √≥rf√£o, for√ßando recria√ß√£o");
          force = true;
        } else {
          console.info("[corner] Reutilizando inst√¢ncia existente do PIXI");
          return; // Tudo OK, j√° est√° inicializado
        }
      }

      // Destruir inst√¢ncia antiga (se existir)
      if (PIXI_APP) {
        console.info("[corner] Destruindo inst√¢ncia anterior do PIXI");
        try {
          // 1. Limpa o cache de texturas ANTES de destruir (cr√≠tico!)
          if (PIXI.utils && PIXI.utils.clearTextureCache) {
            console.info("[corner] Limpando cache de texturas");
            PIXI.utils.clearTextureCache();
          }

          // 2. Destr√≥i todos os sprites e containers recursivamente
          if (SCENE.world) {
            SCENE.world.destroy({
              children: true,
              texture: true,
              baseTexture: true,
            });
            SCENE.world = null;
          }

          // 3. Limpa refer√™ncias do atlas
          if (SCENE.atlas && SCENE.atlas.frames) {
            Object.values(SCENE.atlas.frames).forEach((tex) => {
              try {
                if (tex && tex.destroy) {
                  tex.destroy(true);
                }
              } catch (e) {
                console.warn("[corner] Erro ao destruir textura:", e);
              }
            });
            SCENE.atlas.frames = {};
            SCENE.atlas.ready = false;
          }

          // 4. Limpa o mapa de itens
          SCENE.items.clear();

          // 5. For√ßa a limpeza do contexto WebGL
          if (PIXI_APP.renderer && PIXI_APP.renderer.gl) {
            const gl = PIXI_APP.renderer.gl;
            const loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              console.info("[corner] For√ßando perda de contexto WebGL");
              loseContext.loseContext();
            }
          }

          // 6. Remove o canvas do DOM
          if (PIXI_APP.view && PIXI_APP.view.parentNode) {
            PIXI_APP.view.parentNode.removeChild(PIXI_APP.view);
          }

          // 7. Destr√≥i a aplica√ß√£o
          PIXI_APP.destroy(true, {
            children: true,
            texture: true,
            baseTexture: true,
          });
        } catch (e) {
          console.error("[corner] Erro ao destruir PIXI:", e);
        }

        PIXI_APP = null;
        window.__PIXI_APP_GLOBAL = null;

        // Aguarda um frame para garantir que o contexto foi limpo
        await new Promise((resolve) => requestAnimationFrame(resolve));
      }

      console.info("[corner] Criando nova inst√¢ncia do PIXI");
      PIXI_APP = new PIXI.Application({
        backgroundAlpha: 0,
        resizeTo: container,
        antialias: true,
      });

      // Salva refer√™ncia global
      window.__PIXI_APP_GLOBAL = PIXI_APP;

      container.innerHTML = "";
      container.appendChild(PIXI_APP.view);

      // container raiz do mundo para permitir zoom/pan
      SCENE.world = new PIXI.Container();
      SCENE.world.sortableChildren = true;
      PIXI_APP.stage.addChild(SCENE.world);

      // origem fixa do mundo para proje√ß√£o est√°vel
      HS_ISO.computeOrigin(container);
      drawFloor(SCENE.world);
      drawWalls(SCENE.world);
      SCENE.items.clear();
      SCENE.atlas = await loadAtlasIfAny();
      (window.__cornerItems || []).forEach(addOrUpdateItem);

      // teclado (inclui Space para pan)
      const containerEl = document.getElementById("corner-canvas");
      BOUND.keydown = (ev) => {
        // ignora quando digitando em inputs
        const t = ev.target;
        const tag = (t && t.tagName) || "";
        const editing =
          tag === "INPUT" || tag === "TEXTAREA" || (t && t.isContentEditable);
        if (ev.code === "Space" && !editing) {
          if (!SCENE.spaceDown) {
            SCENE.spaceDown = true;
            if (containerEl) containerEl.style.cursor = "grab";
          }
          ev.preventDefault();
          return;
        }
        onKey(ev);
      };
      BOUND.keyup = (ev) => {
        if (ev.code === "Space") {
          SCENE.spaceDown = false;
          const el = document.getElementById("corner-canvas");
          // mant√©m 'grabbing' caso ainda esteja arrastando; sen√£o limpa
          if (el && !(SCENE.pan && SCENE.pan.active)) el.style.cursor = "";
        }
      };
      window.addEventListener("keydown", BOUND.keydown);
      window.addEventListener("keyup", BOUND.keyup);

      // zoom toolbar
      const btnIn = document.getElementById("btn-zoom-in");
      const btnOut = document.getElementById("btn-zoom-out");
      const btnReset = document.getElementById("btn-zoom-reset");
      if (btnIn) btnIn.onclick = () => setZoom((SCENE.zoom || 1) + 0.1);
      if (btnOut) btnOut.onclick = () => setZoom((SCENE.zoom || 1) - 0.1);
      if (btnReset) btnReset.onclick = () => setZoom(1);
      updateZoomLabel(SCENE.zoom || 1);
      // bind cores globais
      const inCanvas = document.getElementById("color-canvas");
      const inFloor = document.getElementById("color-floor");
      const inWall = document.getElementById("color-wall");
      // aplicar cor do canvas na √°rea externa (section), n√£o no WebGL
      const sectionEl = document.querySelector("section.relative.rounded-xl");
      if (sectionEl)
        sectionEl.style.backgroundColor = numberToHex(SCENE.canvasColor);
      if (inCanvas) {
        try {
          inCanvas.value = numberToHex(SCENE.canvasColor);
        } catch {}
        // preview ao arrastar (sem persistir)
        inCanvas.oninput = () => {
          SCENE.canvasColor = hexToNumber(inCanvas.value);
          const sec = document.querySelector("section.relative.rounded-xl");
          if (sec) sec.style.backgroundColor = numberToHex(SCENE.canvasColor);
        };
        // salva apenas no change (confirma√ß√£o)
        inCanvas.onchange = () => {
          SCENE.canvasColor = hexToNumber(inCanvas.value);
          SCENE.savedCanvasColor = SCENE.canvasColor;
          const sec = document.querySelector("section.relative.rounded-xl");
          if (sec) sec.style.backgroundColor = numberToHex(SCENE.canvasColor);
          saveCornerColors({ canvas: SCENE.canvasColor });
        };
      }
      if (inFloor) {
        try {
          inFloor.value = numberToHex(SCENE.floorColor);
        } catch {}
        // preview ao arrastar (sem persistir)
        inFloor.oninput = () => {
          SCENE.floorColor = hexToNumber(inFloor.value);
          drawFloor(SCENE.world);
        };
        // salva apenas no change (confirma√ß√£o)
        inFloor.onchange = () => {
          SCENE.floorColor = hexToNumber(inFloor.value);
          SCENE.savedFloorColor = SCENE.floorColor;
          drawFloor(SCENE.world);
          saveCornerColors({ floor: SCENE.floorColor });
        };
      }
      if (inWall) {
        try {
          inWall.value = numberToHex(SCENE.wallColor);
        } catch {}
        // preview ao arrastar (sem persistir)
        inWall.oninput = () => {
          SCENE.wallColor = hexToNumber(inWall.value);
          drawWalls(SCENE.world);
        };
        // salva apenas no change (confirma√ß√£o)
        inWall.onchange = () => {
          SCENE.wallColor = hexToNumber(inWall.value);
          SCENE.savedWallColor = SCENE.wallColor;
          drawWalls(SCENE.world);
          saveCornerColors({ wall: SCENE.wallColor });
        };
      }
    }

    function setZoom(value) {
      const container = document.getElementById("corner-canvas");
      if (!SCENE.world || !container) return;
      const rect = container.getBoundingClientRect();
      const mx = rect.width / 2;
      const my = rect.height / 2;
      const next = Math.max(0.25, Math.min(2.0, Number(value) || 1));
      const local = SCENE.world.toLocal(new PIXI.Point(mx, my));
      SCENE.world.pivot.set(local.x, local.y);
      SCENE.world.position.set(mx, my);
      SCENE.world.scale.set(next);
      SCENE.zoom = next;
      updateZoomLabel(next);
      if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
    }

    function updateZoomLabel(val) {
      const lab = document.getElementById("zoom-label");
      if (!lab) return;
      const pct = Math.round((Number(val) || 1) * 100);
      lab.textContent = `${pct}%`;
    }

    function drawFloor(stage) {
      // limpa floor anterior
      if (SCENE.floor) {
        try {
          SCENE.floor.destroy({ children: true });
        } catch (_) {}
      }
      SCENE.floor = new PIXI.Container();
      const gBack = new PIXI.Graphics();
      const g = new PIXI.Graphics();
      const { gridN, tileW, tileH } = HS_ISO;
      // calcula os v√©rtices do losango externo do piso
      const topC = HS_ISO.projectWorld(0, 0);
      const rightC = HS_ISO.projectWorld(gridN - 1, 0);
      const bottomC = HS_ISO.projectWorld(gridN - 1, gridN - 1);
      const leftC = HS_ISO.projectWorld(0, gridN - 1);
      const top = { x: topC.sx, y: topC.sy - tileH / 2 };
      const right = { x: rightC.sx + tileW / 2, y: rightC.sy };
      const bottom = { x: bottomC.sx, y: bottomC.sy + tileH / 2 };
      const left = { x: leftC.sx - tileW / 2, y: leftC.sy };
      // fundo neutro da √°rea jog√°vel (losango + extens√£o da parede para cima)
      const wallH = getWallHeight();
      const extTop = { x: top.x, y: top.y - wallH };
      const extRight = { x: right.x, y: right.y - wallH };
      const extLeft = { x: left.x, y: left.y - wallH };
      // base neutra para n√£o influenciar as cores do piso/parede
      const areaBase = 0x0a0a0a;
      gBack.beginFill(areaBase, 1.0);
      gBack.drawPolygon([
        extTop.x,
        extTop.y,
        extRight.x,
        extRight.y,
        right.x,
        right.y,
        bottom.x,
        bottom.y,
        left.x,
        left.y,
        extLeft.x,
        extLeft.y,
      ]);
      gBack.endFill();
      // preenchimento opaco para corresponder exatamente √† cor escolhida
      g.beginFill(SCENE.floorColor >>> 0, 1.0);
      g.drawPolygon([
        top.x,
        top.y,
        right.x,
        right.y,
        bottom.x,
        bottom.y,
        left.x,
        left.y,
      ]);
      g.endFill();
      SCENE.floor.addChild(gBack);
      SCENE.floor.addChild(g);
      stage.addChild(SCENE.floor);
    }

    // Desenha paredes nas bordas superiores (top-left e top-right)
    function drawWalls(stage) {
      // limpa paredes anteriores
      if (SCENE.walls) {
        try {
          SCENE.walls.destroy({ children: true });
        } catch (_) {}
      }
      SCENE.walls = new PIXI.Container();
      SCENE.walls.zIndex = 20; // acima do piso, abaixo dos itens
      const { gridN } = HS_ISO;
      const wallH = getWallHeight(); // altura visual da parede (unificada)

      function makeStrip(
        points,
        h,
        color = SCENE.wallColor >>> 0,
        alpha = 1.0
      ) {
        if (!points.length) return null;
        const poly = [];
        // borda base (ao longo do piso)
        points.forEach((p) => poly.push(p.sx, p.sy));
        // borda superior (offset para cima da tela)
        for (let i = points.length - 1; i >= 0; i--) {
          const p = points[i];
          poly.push(p.sx, p.sy - h);
        }
        const g = new PIXI.Graphics();
        g.beginFill(color, alpha);
        g.drawPolygon(poly);
        g.endFill();
        return g;
      }

      // Top-right edge (gy = 0, gx 0..N-1)
      const { tileW, tileH } = HS_ISO;
      const topCenter = HS_ISO.projectWorld(0, 0);
      const topApex = { sx: topCenter.sx, sy: topCenter.sy - tileH / 2 };

      // Top-right edge: do √°pice superior at√© o √°pice direito (v√©rtices direitos da linha gy=0)
      const edgeTR = [topApex];
      for (let gx = 0; gx < gridN; gx++) {
        const p = HS_ISO.projectWorld(gx, 0);
        edgeTR.push({ sx: p.sx + tileW / 2, sy: p.sy });
      }
      const wallTR = makeStrip(edgeTR, wallH);
      if (wallTR) SCENE.walls.addChild(wallTR);

      // Top-left edge (gx = 0, gy 0..N-1)
      // Top-left edge: do √°pice superior at√© o √°pice esquerdo (v√©rtices esquerdos da coluna gx=0)
      const edgeTL = [topApex];
      for (let gy = 0; gy < gridN; gy++) {
        const p = HS_ISO.projectWorld(0, gy);
        edgeTL.push({ sx: p.sx - tileW / 2, sy: p.sy });
      }
      const wallTL = makeStrip(edgeTL, wallH);
      if (wallTL) SCENE.walls.addChild(wallTL);

      stage.addChild(SCENE.walls);
      if (stage.sortChildren) stage.sortChildren();
    }

    function textureFromUrl(url) {
      try {
        if (typeof url === "string" && url.startsWith("data:")) {
          const img = new Image();
          img.src = url;
          const base = PIXI.BaseTexture.from(img);
          return new PIXI.Texture(base);
        }
      } catch (_) {}
      return PIXI.Texture.from(url);
    }

    // Normaliza caminhos legados para o atlas (baseado no nome do arquivo)
    function normalizeLegacyUrl(k) {
      try {
        if (k == null) return k;
        let s = String(k);
        if (!s) return k;
        // normaliza prefixos e remove "public/" duplicado
        s = s.replace(/^\.\/?/, "");
        // garante barra inicial para caminhos servidos em /public
        if (s.startsWith("public/")) s = "/" + s;
        // j√° est√° no atlas
        if (/\/public\/assets\/atlas\//i.test(s)) return s;
        // mapeia qualquer pasta antiga para o atlas pelo nome do arquivo
        if (
          /\/public\//i.test(s) ||
          /\.(png|jpg|jpeg|webp|gif|svg)$/i.test(s)
        ) {
          const fname = s.split("/").pop();
          if (fname) return `/public/assets/atlas/${fname}`;
        }
        return s;
      } catch (_) {
        return k;
      }
    }

    function spriteFor(item) {
      // PISO: desenha como losango s√≥lido (sem borda), cor customiz√°vel
      if (item.item_key === "piso") {
        // Estrutura: rot (pai) -> stretch (filho) -> n√≥ (graphics)
        const rot = new PIXI.Container();
        const stretch = new PIXI.Container();
        rot.addChild(stretch);
        const g = new PIXI.Graphics();
        const color = getItemColor(item);
        const { tileW, tileH } = HS_ISO;
        // preenchimento opaco para n√£o sofrer influ√™ncia do piso global
        g.beginFill(color, 1.0);
        g.drawPolygon([
          0,
          -tileH / 2,
          tileW / 2,
          0,
          0,
          tileH / 2,
          -tileW / 2,
          0,
        ]);
        g.endFill();
        stretch.addChild(g);
        // Refer√™ncias para aplica√ß√£o de transforms
        rot.hsRot = rot; // rota√ß√£o do item
        rot.hsStretch = stretch; // escala n√£o-uniforme alinhada √† rota√ß√£o
        rot.hsNode = g; // base scale, flip e tilt
        rot.eventMode = "static";
        rot.cursor = "pointer";
        return rot;
      }
      // PAREDE: desenha como faixa extrudada alinhada √† malha, sem rota√ß√£o
      if (item.item_key === "parede") {
        const c = new PIXI.Container();
        const g = new PIXI.Graphics();
        const wallH = getWallHeight();
        const color = getItemColor(item);
        const sxl = Math.max(
          0.25,
          Math.min(3.0, Number(item.stretch_x || 1.0))
        );
        const length =
          Math.max(0.25, Math.min(2.0, Number(item.scale || 1.0))) * sxl;
        // escolher dire√ß√£o a partir da rota√ß√£o (quantizada)
        const q = quantizeWallRotation(Number(item.rotation || 0));
        const isTR = q === 26.565 || q === 206.565;
        const dir = isTR
          ? { dx: HS_ISO.tileW / 2, dy: HS_ISO.tileH / 2 }
          : { dx: -HS_ISO.tileW / 2, dy: HS_ISO.tileH / 2 };
        const hx = (dir.dx * length) / 2;
        const hy = (dir.dy * length) / 2;
        // pontos da base, centrados na origem do container
        const A = { x: -hx, y: -hy };
        const B = { x: hx, y: hy };
        // topo: mesmo x, y - wallH (vertical na tela)
        const A2 = { x: A.x, y: A.y - wallH };
        const B2 = { x: B.x, y: B.y - wallH };
        // desenha paralelogramo com leve transpar√™ncia para manter o look anterior
        g.beginFill(color, 0.24);
        g.drawPolygon([A.x, A.y, B.x, B.y, B2.x, B2.y, A2.x, A2.y]);
        g.endFill();
        c.addChild(g);
        c.hsSpr = g;
        c.eventMode = "static";
        c.cursor = "pointer";
        return c;
      }

      const c = new PIXI.Container();
      const textures = {
        table: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='8' y='24' width='48' height='16' rx='4' fill='%23c4b5fd'/><rect x='12' y='40' width='8' height='12' fill='%239b87f5'/><rect x='44' y='40' width='8' height='12' fill='%239b87f5'/></svg>`,
        chair: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='20' y='20' width='24' height='12' rx='3' fill='%23f0abfc'/><rect x='18' y='32' width='28' height='10' rx='3' fill='%23d946ef'/><rect x='22' y='42' width='6' height='12' fill='%239b87f5'/><rect x='36' y='42' width='6' height='12' fill='%239b87f5'/></svg>`,
        plant: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='18' r='8' fill='%234ade80'/><path d='M32 26v24' stroke='%230a0a0a' stroke-width='3'/><rect x='22' y='42' width='20' height='12' rx='2' fill='%238b5cf6'/></svg>`,
        lamp: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><polygon points='20,18 44,18 38,8 26,8' fill='%23fde68a'/><rect x='30' y='18' width='4' height='26' fill='%239b87f5'/><rect x='24' y='44' width='16' height='6' rx='2' fill='%237c3aed'/></svg>`,
        sofa: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='8' y='26' width='80' height='22' rx='6' fill='%23a78bfa'/><rect x='8' y='16' width='80' height='14' rx='6' fill='%23c4b5fd'/><rect x='12' y='48' width='10' height='6' fill='%239b87f5'/><rect x='74' y='48' width='10' height='6' fill='%239b87f5'/></svg>`,
        tv: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='10' y='8' width='76' height='46' rx='6' fill='%230a0a0a'/><rect x='14' y='12' width='68' height='38' rx='4' fill='%23252525'/><rect x='40' y='54' width='16' height='4' fill='%237c3aed'/></svg>`,
        piso: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='72' height='36'><defs><linearGradient id='g' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='%23201533' stop-opacity='0.9'/><stop offset='100%' stop-color='%23110a1b' stop-opacity='0.9'/></linearGradient></defs><polygon points='36,0 72,18 36,36 0,18' fill='url(%23g)'/></svg>`,
        parede: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='72' height='80'><defs><linearGradient id='w' x1='0' y1='0' x2='0' y2='1'><stop offset='0%' stop-color='%233f1d5b' stop-opacity='0.9'/><stop offset='100%' stop-color='%23110a1b' stop-opacity='0.9'/></linearGradient></defs><polygon points='0,64 72,64 72,0 0,0' fill='url(%23w)'/></svg>`,
      };
      let tex = null;
      if (SCENE.atlas && SCENE.atlas.ready) {
        const key = item.item_key;
        const candidates = [key, `${key}.png`, `${key}.webp`, `${key}.jpg`];
        for (const k of candidates) {
          if (SCENE.atlas.frames[k]) {
            tex = SCENE.atlas.frames[k];
            break;
          }
        }
      }
      if (!tex) {
        // suportar item_key como caminho/URL de imagem
        const key = String(item.item_key || "");
        const normKey = normalizeLegacyUrl(key);
        const looksLikeImg =
          /\.(png|jpg|jpeg|webp|gif|svg)$/i.test(normKey) ||
          normKey.startsWith("/public/");
        const url = looksLikeImg
          ? normKey
          : textures[item.item_key] ||
            `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='10' fill='%23a78bfa'/></svg>`;
        tex = textureFromUrl(url);
      }
      // Estrutura: rot (pai) -> stretch (filho) -> node (filho) -> [shadow, spr]
      const rot = new PIXI.Container();
      const stretch = new PIXI.Container();
      const node = new PIXI.Container();
      rot.addChild(stretch);
      stretch.addChild(node);
      const spr = new PIXI.Sprite(tex);
      spr.anchor.set(0.5);
      // sombra: n√£o desenhar para piso nem para parede
      if (item.item_key !== "piso" && item.item_key !== "parede") {
        const shadow = new PIXI.Graphics();
        shadow.beginFill(0x000000, 0.18);
        shadow.drawEllipse(0, 18, 14, 4);
        shadow.endFill();
        shadow.zIndex = -1;
        node.addChild(shadow);
      }
      node.addChild(spr);
      // escala base inicial (para ghost e cria√ß√£o), flips aplicados depois em addOrUpdateItem
      const baseScale =
        item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
      const userScale = Number(item.scale || 1.0);
      node.scale.set(baseScale * userScale);
      // refer√™ncias para transforms
      rot.hsStretch = stretch;
      rot.hsRot = rot;
      rot.hsNode = node;
      rot.hsSpr = spr;
      rot.eventMode = "static";
      rot.cursor = "pointer";
      return rot;
    }

    // ==== Cores: helpers e override local (n√£o persistido) ====
    function hexToNumber(hex) {
      if (!hex) return 0x000000;
      const s = String(hex).trim();
      const h = s.startsWith("#") ? s.slice(1) : s;
      return Number.parseInt(h, 16) || 0x000000;
    }
    function numberToHex(num) {
      const n = Number(num) >>> 0;
      return "#" + n.toString(16).padStart(6, "0");
    }
    function getItemColor(item) {
      // defaults
      const def =
        item.item_key === "parede"
          ? 0xf0f0f0 // padr√£o da parede (cinza claro)
          : item.item_key === "piso"
          ? 0x7c3aed
          : 0xffffff;
      try {
        // prioridade: override local (edi√ß√£o atual) > item.color persistido > default
        const ov = SCENE.colorOverrides.get(item.id);
        if (typeof ov === "number") return ov;
        if (typeof item.color === "number" && Number.isFinite(item.color))
          return item.color >>> 0;
        return def;
      } catch {
        return def;
      }
    }
    function setItemColor(id, colorNum) {
      try {
        SCENE.colorOverrides.set(id, colorNum >>> 0);
        const entry = SCENE.items.get(id);
        if (!entry) return;
        const item = entry.item;
        if (item.item_key === "parede" || item.item_key === "piso") {
          const parent = entry.sprite.parent;
          const prevX = entry.sprite.x;
          const prevY = entry.sprite.y;
          const prevZ = entry.sprite.zIndex;
          entry.sprite.destroy({ children: true });
          const rebuilt = spriteFor(item);
          rebuilt.x = prevX;
          rebuilt.y = prevY;
          if (typeof prevZ === "number") rebuilt.zIndex = prevZ;
          // piso opaco; parede volta a ter leve transpar√™ncia no container
          rebuilt.alpha = item.item_key === "piso" ? 1.0 : 0.98;
          rebuilt.on("pointerdown", (e) => {
            SCENE.justClickedSprite = true;
            setTimeout(() => (SCENE.justClickedSprite = false), 0);
            startDrag(item.id, e);
          });
          rebuilt.on("pointertap", () => selectItem(item.id));
          if (parent) parent.addChild(rebuilt);
          entry.sprite = rebuilt;
          if (SCENE.selectedId === id) updateOverlayPosition(id);
        }
      } catch {}
    }

    // ===== Ghost (preview durante drag) =====
    function hideGhost() {
      if (SCENE.ghost && SCENE.ghost.container) {
        try {
          SCENE.ghost.container.destroy({ children: true });
        } catch (_) {}
      }
      SCENE.ghost = null;
    }
    function ensureGhost(key) {
      if (SCENE.ghost && SCENE.ghost.key === key && SCENE.ghost.container)
        return SCENE.ghost.container;
      // recria ghost
      hideGhost();
      const item = {
        item_key: key,
        scale: 1.0,
        rotation: 0,
        z: 0,
        tilt_x: 0,
        tilt_y: 0,
        flip_x: 0,
        flip_y: 0,
      };
      const cont = spriteFor(item);
      cont.alpha = 0.6;
      cont.eventMode = "none";
      // esconder apenas a sombra do ghost (zIndex -1), n√£o a geometria principal (busca recursiva)
      (function hideGhostShadows(node) {
        if (!node || !node.children) return;
        for (const ch of node.children) {
          if (ch && typeof ch.zIndex === "number" && ch.zIndex === -1) {
            ch.visible = false;
          }
          if (ch && ch.children && ch.children.length) hideGhostShadows(ch);
        }
      })(cont);
      cont.zIndex = 100000;
      if (SCENE.world) {
        SCENE.world.addChild(cont);
        SCENE.world.sortChildren();
      }
      SCENE.ghost = { key, container: cont };
      return cont;
    }
    function updateGhostPosition(px, py) {
      if (!SCENE.world || !SCENE.ghost || !SCENE.ghost.container) return;
      const ptLocal = SCENE.world.toLocal(new PIXI.Point(px, py));
      let best = { d: Infinity, gx: 0, gy: 0 };
      for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
        for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const dx = sx - ptLocal.x,
            dy = sy - ptLocal.y;
          const d = dx * dx + dy * dy;
          if (d < best.d) best = { d, gx: i, gy: j };
        }
      }
      // clamp at√© as bordas da grade (permitir borda do canvas)
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
      const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
      const { sx, sy } = HS_ISO.projectWorld(gx, gy);
      SCENE.ghost.container.x = sx;
      SCENE.ghost.container.y = sy;
    }

    function addOrUpdateItem(item) {
      const container = document.getElementById("corner-canvas");
      const { sx, sy } = HS_ISO.projectWorld(
        pctToGrid(item.x),
        pctToGrid(item.y)
      );
      const sy3d = sy - item.z * (HS_ISO.tileH / 2);
      let entry = SCENE.items.get(item.id);
      if (!entry) {
        const sprite = spriteFor(item);
        sprite.x = sx;
        sprite.y = sy3d;
        // rota√ß√£o: parede n√£o roda o container; demais items usam hsRot
        if (item.item_key !== "parede") {
          const rotDeg = Number(item.rotation || 0);
          if (sprite.hsRot) sprite.hsRot.rotation = (rotDeg * Math.PI) / 180;
          else sprite.rotation = (rotDeg * Math.PI) / 180;
        }
        // itens padr√£o levemente abaixo de 1; piso/parede opacos (ajustado abaixo)
        sprite.alpha =
          item.item_key === "piso" || item.item_key === "parede" ? 1.0 : 0.98;
        // aplica escala/tilt/flip/stretches (n√£o aplica em "parede" para manter geometria reta)
        if (item.item_key !== "parede") {
          const base =
            item.item_key === "sofa" || item.item_key === "tv"
              ? 0.75
              : item.item_key === "piso"
              ? 1.0
              : 0.6;
          const scl = Number(item.scale || 1.0);
          const stx = Math.max(
            0.25,
            Math.min(3.0, Number(item.stretch_x || 1.0))
          );
          const sty = Math.max(
            0.25,
            Math.min(3.0, Number(item.stretch_y || 1.0))
          );
          if (sprite.hsNode) {
            const sxNode = (item.flip_x ? -1 : 1) * base * scl;
            const syNode = (item.flip_y ? -1 : 1) * base * scl;
            sprite.hsNode.scale.set(sxNode, syNode);
            const kx = Number(item.tilt_x || 0) * (Math.PI / 180);
            const ky = Number(item.tilt_y || 0) * (Math.PI / 180);
            sprite.hsNode.skew.set(kx, ky);
          }
          if (sprite.hsStretch) {
            sprite.hsStretch.scale.set(stx, sty);
          }
        }
        sprite.on("pointerdown", (e) => {
          // Evita que o clique no sprite limpe a sele√ß√£o via handler global
          SCENE.justClickedSprite = true;
          setTimeout(() => (SCENE.justClickedSprite = false), 0);
          startDrag(item.id, e);
        });
        sprite.on("pointertap", () => selectItem(item.id));
        SCENE.world.addChild(sprite);
        entry = { item: { ...item }, sprite };
        SCENE.items.set(item.id, entry);
      } else {
        entry.item = { ...item };
        entry.sprite.x = sx;
        entry.sprite.y = sy3d;
        if (item.item_key !== "parede") {
          const rotDeg2 = Number(item.rotation || 0);
          if (entry.sprite.hsRot)
            entry.sprite.hsRot.rotation = (rotDeg2 * Math.PI) / 180;
          else entry.sprite.rotation = (rotDeg2 * Math.PI) / 180;
        } else {
          // reconstruir geometria da parede com base em rota√ß√£o/escala
          const parent = entry.sprite.parent;
          // preservar posi√ß√£o antes de destruir
          const prevX = entry.sprite.x;
          const prevY = entry.sprite.y;
          const prevZ = entry.sprite.zIndex;
          entry.sprite.destroy({ children: true });
          const rebuilt = spriteFor(item);
          rebuilt.x = prevX;
          rebuilt.y = prevY;
          if (typeof prevZ === "number") rebuilt.zIndex = prevZ;
          rebuilt.alpha =
            item.item_key === "piso" || item.item_key === "parede" ? 1.0 : 0.98;
          rebuilt.on("pointerdown", (e) => {
            SCENE.justClickedSprite = true;
            setTimeout(() => (SCENE.justClickedSprite = false), 0);
            startDrag(item.id, e);
          });
          rebuilt.on("pointertap", () => selectItem(item.id));
          if (parent) parent.addChild(rebuilt);
          entry.sprite = rebuilt;
        }
        // aplica escala/tilt/flip/stretches (n√£o aplica em "parede" para manter geometria reta)
        if (item.item_key !== "parede") {
          const base =
            item.item_key === "sofa" || item.item_key === "tv"
              ? 0.75
              : item.item_key === "piso"
              ? 1.0
              : 0.6;
          const scl = Number(item.scale || 1.0);
          const stx = Math.max(
            0.25,
            Math.min(3.0, Number(item.stretch_x || 1.0))
          );
          const sty = Math.max(
            0.25,
            Math.min(3.0, Number(item.stretch_y || 1.0))
          );
          if (entry.sprite.hsNode) {
            const sxNode = (item.flip_x ? -1 : 1) * base * scl;
            const syNode = (item.flip_y ? -1 : 1) * base * scl;
            entry.sprite.hsNode.scale.set(sxNode, syNode);
            const kx = Number(item.tilt_x || 0) * (Math.PI / 180);
            const ky = Number(item.tilt_y || 0) * (Math.PI / 180);
            entry.sprite.hsNode.skew.set(kx, ky);
          }
          if (entry.sprite.hsStretch) {
            entry.sprite.hsStretch.scale.set(stx, sty);
          }
        }
      }
      sortByDepth();
    }

    function sortByDepth() {
      const arr = Array.from(SCENE.items.values());
      arr.sort((a, b) => {
        const la = Number(a.item.layer || 0);
        const lb = Number(b.item.layer || 0);
        if (la !== lb) return la - lb; // layer menor fica atr√°s
        return a.sprite.y - b.sprite.y; // empate: usa profundidade isom√©trica
      });
      arr.forEach((e, i) => (e.sprite.zIndex = 100 + i));
      if (SCENE.world) SCENE.world.sortChildren();
    }

    let DRAG = null;
    function startDrag(id, e) {
      selectItem(id);
      // inicia drag j√° com a posi√ß√£o atual do item para evitar (0,0) se n√£o houver movimento
      const entry = SCENE.items.get(id);
      let gx0 = 0,
        gy0 = 0;
      try {
        if (entry && entry.item) {
          gx0 = pctToGrid(entry.item.x);
          gy0 = pctToGrid(entry.item.y);
        }
      } catch {}
      DRAG = { id, gx: gx0, gy: gy0 };
      const up = () => {
        if (!DRAG) return;
        finishDrag();
        window.removeEventListener("pointerup", up);
        window.removeEventListener("pointermove", move);
      };
      const move = (ev) => dragMove(ev);
      window.addEventListener("pointerup", up);
      window.addEventListener("pointermove", move);
    }
    function dragMove(ev) {
      if (!DRAG) return;
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) return;
      const container = document.getElementById("corner-canvas");
      const rect = container.getBoundingClientRect();
      const px = ev.clientX - rect.left;
      const py = ev.clientY - rect.top;
      // converte para coordenadas do mundo (compensa zoom/pan)
      const ptLocal = SCENE.world
        ? SCENE.world.toLocal(new PIXI.Point(px, py))
        : new PIXI.Point(px, py);
      let best = { d: Infinity, gx: 0, gy: 0, sx: 0, sy: 0 };
      for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
        for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const sy3d = sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
          const dx = sx - ptLocal.x,
            dy = sy3d - ptLocal.y;
          const d = dx * dx + dy * dy;
          if (d < best.d) best = { d, gx: i, gy: j, sx, sy: sy3d };
        }
      }
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
      const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
      const p = HS_ISO.projectWorld(gx, gy);
      const sy3d = p.sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
      entry.sprite.x = p.sx;
      entry.sprite.y = sy3d;
      DRAG.gx = gx;
      DRAG.gy = gy;
      if (SCENE.selectedId === DRAG.id) updateOverlayPosition(DRAG.id);
    }
    async function finishDrag() {
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) {
        DRAG = null;
        return;
      }
      // robustez: se por algum motivo gx/gy n√£o foram definidos, usa posi√ß√£o atual do item
      const gx =
        DRAG.gx != null && Number.isFinite(DRAG.gx)
          ? DRAG.gx
          : pctToGrid(entry.item.x);
      const gy =
        DRAG.gy != null && Number.isFinite(DRAG.gy)
          ? DRAG.gy
          : pctToGrid(entry.item.y);
      const xPct = gridToPct(gx);
      const yPct = gridToPct(gy);
      const ok = await savePosition(DRAG.id, xPct, yPct);
      if (ok) {
        entry.item.x = xPct;
        entry.item.y = yPct;
      }
      sortByDepth();
      DRAG = null;
    }

    function selectItem(id) {
      SCENE.selectedId = id;
      // Removido highlight por escala para n√£o interferir com stretch/rota√ß√£o
      updateOverlayPosition(id);
      bindOverlayActions(id);
    }

    function updateOverlayPosition(id) {
      const entry = SCENE.items.get(id);
      const overlay = document.getElementById("corner-overlay");
      const container = document.getElementById("corner-canvas");
      if (!entry || !overlay || !container) return;
      overlay.classList.remove("hidden");
      const gap = 8;
      // posi√ß√£o global do sprite (considera zoom/pan)
      const gp = entry.sprite.getGlobalPosition();
      const px = Math.round(gp.x);
      const py = Math.round(gp.y);
      // remover transform para medir corretamente
      overlay.style.transform = "none";
      // for√ßa c√°lculo de dimens√µes
      const w = overlay.offsetWidth || 160;
      const h = overlay.offsetHeight || 32;
      const cw = container.clientWidth || 0;
      const ch = container.clientHeight || 0;
      // preferir acima
      let left = Math.round(px - w / 2);
      let top = Math.round(py - (h + gap));
      // se n√£o couber acima, coloca abaixo
      if (top < 4) top = Math.round(py + gap);
      // clamp para dentro do canvas
      const minX = 4;
      const minY = 4;
      const maxX = Math.max(minX, cw - w - 4);
      const maxY = Math.max(minY, ch - h - 4);
      left = Math.max(minX, Math.min(maxX, left));
      top = Math.max(minY, Math.min(maxY, top));
      overlay.style.left = left + "px";
      overlay.style.top = top + "px";
      updateOverlayScaleDisplay(id);
      updateOverlayStretchDisplay(id);
      updateOverlayColorDisplay(id);
    }

    // updateOverlayRotationDisplay removido: overlay n√£o cont√©m indicador de rota√ß√£o

    function updateOverlayScaleDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const input = document.getElementById("overlay-scale");
        if (!entry || !input) return;
        input.value = Number(entry.item.scale || 1.0).toFixed(2);
      } catch (_) {}
    }

    function updateOverlayStretchDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const inX = document.getElementById("overlay-stretch-x");
        const inY = document.getElementById("overlay-stretch-y");
        if (!entry || !inX || !inY) return;
        const sx = Number(entry.item.stretch_x || 1.0);
        const sy = Number(entry.item.stretch_y || 1.0);
        inX.value = sx.toFixed(2);
        inY.value = sy.toFixed(2);
        const isWall = entry.item.item_key === "parede";
        inX.disabled = isWall;
        inY.disabled = isWall;
        inX.title = isWall
          ? "Paredes usam 'escala' para comprimento e mant√™m altura fixa"
          : "Esticar largura (X)";
        inY.title = isWall
          ? "Altura da parede √© fixa para manter o visual"
          : "Esticar altura (Y)";
      } catch (_) {}
    }

    function bindOverlayActions(id) {
      const overlay = document.getElementById("corner-overlay");
      if (!overlay) return;
      const idSel = id;
      // Dica de rota√ß√£o removida: overlay n√£o exibe mais orienta√ß√µes de rota√ß√£o
      const btnDel = document.getElementById("btn-delete");
      const btnLU = document.getElementById("btn-layer-up");
      const btnLD = document.getElementById("btn-layer-down");
      const btnLT = document.getElementById("btn-layer-top");
      const btnLB = document.getElementById("btn-layer-bottom");
      // Color controls visibility and binding
      (function manageColorUI() {
        const entry = SCENE.items.get(idSel);
        const colorWrap = document.getElementById("overlay-color-wrap");
        const input = document.getElementById("overlay-color");
        const isColorable =
          entry &&
          (entry.item.item_key === "parede" || entry.item.item_key === "piso");
        if (colorWrap) colorWrap.classList.toggle("hidden", !isColorable);
        if (isColorable && input) {
          // preview imediato enquanto arrasta a paleta (n√£o persiste)
          input.oninput = (e) => {
            e.stopPropagation();
            const val = String(input.value || "#6b21a8");
            const n = hexToNumber(val);
            setItemColor(idSel, n);
          };
          updateOverlayStretchDisplay(id);
          input.onchange = (e) => {
            e.stopPropagation();
            const val = String(input.value || "#6b21a8");
            const n = hexToNumber(val);
            // feedback local imediato
            setItemColor(idSel, n);
            // persistir no backend
            saveColor(idSel, n).then((ok) => {
              if (!ok) {
                // se falhar, mant√©m override local; nada mais a fazer
                return;
              }
              // ao salvar, removemos override e usamos valor persistido do servidor
              const entry = SCENE.items.get(idSel);
              if (entry) {
                SCENE.colorOverrides.delete(idSel);
                // refazer o sprite com dados do servidor retornados por saveColor
              }
            });
          };
        }
      })();
      if (btnDel)
        btnDel.onclick = async (e) => {
          e.stopPropagation();
          await deleteItem(idSel);
          overlay.classList.add("hidden");
        };
      // bot√µes de rota√ß√£o e altura removidos do overlay

      function layerBounds() {
        let min = 0,
          max = 0;
        SCENE.items.forEach(({ item }) => {
          const l = Number(item.layer || 0);
          if (l < min) min = l;
          if (l > max) max = l;
        });
        return { min, max };
      }
      if (btnLU)
        btnLU.onclick = async (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            const { max } = layerBounds();
            await saveLayer(idSel, max + 1);
          } else {
            await saveStack(idSel, +1);
          }
        };
      if (btnLD)
        btnLD.onclick = async (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            const { min } = layerBounds();
            await saveLayer(idSel, min - 1);
          } else {
            await saveStack(idSel, -1);
          }
        };
      if (btnLT)
        btnLT.onclick = async (e) => {
          e.stopPropagation();
          const { max } = layerBounds();
          await saveLayer(idSel, max + 1);
        };
      if (btnLB)
        btnLB.onclick = async (e) => {
          e.stopPropagation();
          const { min } = layerBounds();
          await saveLayer(idSel, min - 1);
        };

      const inputScale = document.getElementById("overlay-scale");
      const inputStretchX = document.getElementById("overlay-stretch-x");
      const inputStretchY = document.getElementById("overlay-stretch-y");
      const btnInc = document.getElementById("btn-scale-inc");
      const btnDec = document.getElementById("btn-scale-dec");
      async function setScale(val) {
        const scl = Math.max(0.25, Math.min(2.0, Number(val) || 1.0));
        await saveScale(idSel, scl);
        updateOverlayScaleDisplay(idSel);
      }
      if (inputScale) {
        inputScale.onchange = async (e) => {
          e.stopPropagation();
          await setScale(inputScale.value);
        };
      }
      function previewStretchLocal(axis, val) {
        const entry = SCENE.items.get(idSel);
        if (!entry) return;
        if (entry.item.item_key === "parede") return;
        const curX = Math.max(
          0.25,
          Math.min(
            3.0,
            Number(axis === "x" ? val : entry.item.stretch_x || 1.0)
          )
        );
        const curY = Math.max(
          0.25,
          Math.min(
            3.0,
            Number(axis === "y" ? val : entry.item.stretch_y || 1.0)
          )
        );
        if (entry.sprite && entry.sprite.hsStretch) {
          entry.sprite.hsStretch.scale.set(curX, curY);
        }
      }
      async function setStretch(sx, sy) {
        const nx = Math.max(0.25, Math.min(3.0, Number(sx) || 1.0));
        const ny = Math.max(0.25, Math.min(3.0, Number(sy) || 1.0));
        await saveStretch(idSel, nx, ny);
      }
      if (inputStretchX) {
        inputStretchX.oninput = (e) => {
          e.stopPropagation();
          previewStretchLocal("x", Number(inputStretchX.value));
        };
        inputStretchX.onchange = async (e) => {
          e.stopPropagation();
          const sy = document.getElementById("overlay-stretch-y");
          await setStretch(inputStretchX.value, sy ? sy.value : 1.0);
          updateOverlayStretchDisplay(idSel);
        };
      }
      if (inputStretchY) {
        inputStretchY.oninput = (e) => {
          e.stopPropagation();
          previewStretchLocal("y", Number(inputStretchY.value));
        };
        inputStretchY.onchange = async (e) => {
          e.stopPropagation();
          const sx = document.getElementById("overlay-stretch-x");
          await setStretch(sx ? sx.value : 1.0, inputStretchY.value);
          updateOverlayStretchDisplay(idSel);
        };
      }
      if (btnInc)
        btnInc.onclick = async (e) => {
          e.stopPropagation();
          const v = Number((Number(inputScale.value || 1) + 0.05).toFixed(2));
          await setScale(v);
        };
      if (btnDec)
        btnDec.onclick = async (e) => {
          e.stopPropagation();
          const v = Number((Number(inputScale.value || 1) - 0.05).toFixed(2));
          await setScale(v);
        };
    }

    function updateOverlayColorDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const wrap = document.getElementById("overlay-color-wrap");
        const input = document.getElementById("overlay-color");
        if (!entry || !wrap || !input) return;
        const isColorable =
          entry.item.item_key === "parede" || entry.item.item_key === "piso";
        wrap.classList.toggle("hidden", !isColorable);
        if (isColorable) {
          const color = getItemColor(entry.item);
          input.value = numberToHex(color);
        }
      } catch (_) {}
    }

    function clearSelection() {
      SCENE.selectedId = null;
      const overlay = document.getElementById("corner-overlay");
      if (overlay) overlay.classList.add("hidden");
      // Sem highlight visual por escala
    }

    function bindOutsideClicks() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      const onCanvasDown = (ev) => {
        if (SCENE.justClickedSprite) return;
        // n√£o limpar sele√ß√£o quando iniciar pan (bot√£o do meio ou Space+esquerdo)
        if (ev && (ev.button === 1 || (ev.button === 0 && SCENE.spaceDown)))
          return;
        clearSelection();
      };
      container.addEventListener("pointerdown", onCanvasDown);

      const onDocDown = (ev) => {
        const overlay = document.getElementById("corner-overlay");
        if (overlay && overlay.contains(ev.target)) return;
        const insideCanvas =
          ev.target.closest && ev.target.closest("#corner-canvas");
        if (!insideCanvas) clearSelection();
      };
      document.addEventListener("pointerdown", onDocDown);
      BOUND.click = { onCanvasDown, onDocDown };
    }

    // Ajuda (modal)
    function bindHelpModal() {
      const btn = document.getElementById("btn-help");
      const modal = document.getElementById("help-modal");
      const btnClose = document.getElementById("help-close");
      if (!btn || !modal) return;
      const open = () => {
        modal.classList.remove("hidden");
        modal.classList.add("flex");
      };
      const close = () => {
        modal.classList.add("hidden");
        modal.classList.remove("flex");
      };
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        open();
      });
      if (btnClose)
        btnClose.addEventListener("click", (e) => {
          e.stopPropagation();
          close();
        });
      // fecha clicando no backdrop
      modal.addEventListener("click", (e) => {
        if (e.target === modal) close();
      });
      // fecha com ESC
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") close();
      });
    }

    // Pan do canvas (bot√£o do meio ou Space + arrastar com esquerdo)
    function bindPan() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      const onDown = (ev) => {
        const wantPan = ev.button === 1 || (ev.button === 0 && SCENE.spaceDown);
        if (!wantPan) return;
        ev.preventDefault();
        SCENE.pan = SCENE.pan || {};
        SCENE.pan.active = true;
        SCENE.pan.startX = ev.clientX;
        SCENE.pan.startY = ev.clientY;
        SCENE.pan.worldX = SCENE.world ? SCENE.world.position.x : 0;
        SCENE.pan.worldY = SCENE.world ? SCENE.world.position.y : 0;
        container.style.cursor = "grabbing";
        const onMove = (e) => {
          if (!SCENE.pan.active || !SCENE.world) return;
          const dx = e.clientX - SCENE.pan.startX;
          const dy = e.clientY - SCENE.pan.startY;
          SCENE.world.position.set(
            SCENE.pan.worldX + dx,
            SCENE.pan.worldY + dy
          );
          if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
        };
        const onUp = () => {
          SCENE.pan.active = false;
          // se Space ainda est√° segurado, volta para 'grab'; sen√£o limpa
          container.style.cursor = SCENE.spaceDown ? "grab" : "";
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
        };
        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onUp);
      };
      container.addEventListener("pointerdown", onDown);
      BOUND.pan = { onDown };
    }

    async function saveStack(id, dir) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/stack`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dir }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function savePosition(id, x, y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/position`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ x, y }),
        });
        return res.ok;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveNudge(id, dx = 0, dy = 0, drot = 0) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/nudge`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dx, dy, drot }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveHeight(id, dz) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/height`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dz }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function saveScale(id, scale) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/scale`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ scale }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveTilt(id, tilt_x, tilt_y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/tilt`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ tilt_x, tilt_y }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveFlip(id, flip_x, flip_y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/flip`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ flip_x, flip_y }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveLayer(id, layer) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/layer`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ layer }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveCornerColors(partial) {
      try {
        const CSRF =
          (document.querySelector('meta[name="csrf-token"]') || {}).content ||
          "";
        const res = await fetch(`/corner/colors`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
          },
          body: JSON.stringify(partial || {}),
        });
        return res.ok;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveStretch(id, stretch_x, stretch_y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/stretch`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ stretch_x, stretch_y }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function saveColor(id, color) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        // aceita n√∫mero ou string hex
        const payload =
          typeof color === "number"
            ? { color }
            : { color: String(color || "") };
        const res = await fetch(`/corner/items/${id}/color`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify(payload),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function deleteItem(id) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/delete`, {
          method: "POST",
          headers: { "X-CSRF-Token": CSRF, "HX-Request": "true" },
        });
        if (!res.ok) return false;
        removeSprite(id);
        // remove do cache local e atualiza contadores
        try {
          if (Array.isArray(window.__cornerItems)) {
            window.__cornerItems = window.__cornerItems.filter(
              (it) => it.id !== id
            );
          }
        } catch {}
        try {
          refreshGroupCounts && refreshGroupCounts();
        } catch {}
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    function htmlToNode(html) {
      const t = document.createElement("div");
      t.innerHTML = html.trim();
      return t.firstElementChild;
    }
    function removeSprite(id) {
      const e = SCENE.items.get(id);
      if (!e) return;
      e.sprite.destroy({ children: true });
      SCENE.items.delete(id);
    }

    // resize handler
    function bindResize() {
      BOUND.resize = () => {
        if (!PIXI_APP) return;
        const container = document.getElementById("corner-canvas");
        if (container) HS_ISO.computeOrigin(container);
        drawFloor(SCENE.world);
        drawWalls(SCENE.world);
        SCENE.items.forEach(({ item }) => addOrUpdateItem(item));
        if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
      };
      window.addEventListener("resize", BOUND.resize);
    }

    // (Removido) Integra√ß√£o com htmx

    // Teclado
    async function onKey(ev) {
      // n√£o interferir quando digitando em inputs
      const t = ev.target;
      const tag = (t && t.tagName) || "";
      if (tag === "INPUT" || tag === "TEXTAREA" || (t && t.isContentEditable))
        return;
      if (!SCENE.selectedId) return;
      const id = SCENE.selectedId;
      const entry = SCENE.items.get(id);
      if (!entry) return;
      // Removido: movimenta√ß√£o por setas
      if (ev.key.toLowerCase() === "q") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, -15);
      } else if (ev.key.toLowerCase() === "e") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, 15);
      } else if (ev.key.toLowerCase() === "t") {
        // tilt X - inclina√ß√£o no eixo X (skew Y)
        ev.preventDefault();
        const tx = Number(entry.item.tilt_x || 0) - 2;
        await saveTilt(id, tx, entry.item.tilt_y || 0);
      } else if (ev.key.toLowerCase() === "g") {
        ev.preventDefault();
        const tx = Number(entry.item.tilt_x || 0) + 2;
        await saveTilt(id, tx, entry.item.tilt_y || 0);
      } else if (ev.key.toLowerCase() === "y") {
        // tilt Y - inclina√ß√£o no eixo Y (skew X)
        ev.preventDefault();
        const ty = Number(entry.item.tilt_y || 0) - 2;
        await saveTilt(id, entry.item.tilt_x || 0, ty);
      } else if (ev.key.toLowerCase() === "h") {
        ev.preventDefault();
        const ty = Number(entry.item.tilt_y || 0) + 2;
        await saveTilt(id, entry.item.tilt_x || 0, ty);
      } else if (ev.key.toLowerCase() === "f") {
        // flip horizontal
        ev.preventDefault();
        const fx = entry.item.flip_x ? 0 : 1;
        await saveFlip(id, fx, entry.item.flip_y || 0);
      } else if (ev.key.toLowerCase() === "v") {
        // flip vertical
        ev.preventDefault();
        const fy = entry.item.flip_y ? 0 : 1;
        await saveFlip(id, entry.item.flip_x || 0, fy);
      } else if (
        (ev.ctrlKey || ev.metaKey) &&
        (ev.key === "=" || ev.key === "+")
      ) {
        // Prioriza escala com Ctrl/Cmd +
        ev.preventDefault();
        const cur = Number(entry.item.scale || 1.0);
        await saveScale(id, Math.min(2.0, Number((cur + 0.05).toFixed(2))));
      } else if ((ev.ctrlKey || ev.metaKey) && ev.key === "-") {
        // Prioriza escala com Ctrl/Cmd -
        ev.preventDefault();
        const cur = Number(entry.item.scale || 1.0);
        await saveScale(id, Math.max(0.25, Number((cur - 0.05).toFixed(2))));
      } else if (ev.key === "PageUp" || ev.key === "+") {
        ev.preventDefault();
        await saveHeight(id, 1);
      } else if (ev.key === "PageDown" || ev.key === "-") {
        ev.preventDefault();
        await saveHeight(id, -1);
      } else if (ev.key === "]") {
        ev.preventDefault();
        await saveStack(id, +1);
      } else if (ev.key === "[") {
        ev.preventDefault();
        await saveStack(id, -1);
      } else if (ev.key === "Delete") {
        ev.preventDefault();
        await deleteItem(id);
      }
    }

    // Roda do mouse (com Ctrl ou Alt) para girar item selecionado
    function bindWheelRotate() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      container.addEventListener(
        "wheel",
        async (ev) => {
          // Zoom do canvas quando sem modificadores
          if (!ev.ctrlKey && !ev.altKey && !ev.shiftKey) {
            ev.preventDefault();
            const rect = container.getBoundingClientRect();
            const mx = ev.clientX - rect.left;
            const my = ev.clientY - rect.top;
            const dir = ev.deltaY < 0 ? 1 : -1; // roda pra cima = zoom in
            const next = Math.max(0.25, Math.min(2.0, SCENE.zoom + dir * 0.1));
            if (SCENE.world) {
              // ancora o zoom no cursor
              const local = SCENE.world.toLocal(new PIXI.Point(mx, my));
              SCENE.world.pivot.set(local.x, local.y);
              SCENE.world.position.set(mx, my);
              SCENE.world.scale.set(next);
              SCENE.zoom = next;
              updateZoomLabel(next);
              if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
            }
            return;
          }
          if (!SCENE.selectedId) return;
          // Shift: escala; Ctrl/Alt: rota√ß√£o
          if (ev.shiftKey) {
            ev.preventDefault();
            const id = SCENE.selectedId;
            const entry = SCENE.items.get(id);
            const cur = Number(entry?.item?.scale || 1.0);
            const next = ev.deltaY > 0 ? cur - 0.05 : cur + 0.05;
            await saveScale(
              id,
              Math.max(0.25, Math.min(2.0, Number(next.toFixed(2))))
            );
            updateOverlayScaleDisplay(id);
            return;
          }
          if (!ev.ctrlKey && !ev.altKey) return; // somente com modificador
          ev.preventDefault();
          const id = SCENE.selectedId;
          const dir = ev.deltaY > 0 ? 15 : -15;
          await saveNudge(id, 0, 0, dir);
        },
        { passive: false }
      );
    }

    // Expor e inicializar
    function destroy() {
      console.info("[corner] Destruindo inst√¢ncia Corner");
      try {
        if (BOUND.keydown) window.removeEventListener("keydown", BOUND.keydown);
        if (BOUND.keyup) window.removeEventListener("keyup", BOUND.keyup);
        if (BOUND.resize) window.removeEventListener("resize", BOUND.resize);
        // htmx n√£o √© mais utilizado nesta p√°gina
        if (BOUND.click) {
          const container = document.getElementById("corner-canvas");
          if (container && BOUND.click.onCanvasDown)
            container.removeEventListener(
              "pointerdown",
              BOUND.click.onCanvasDown
            );
          if (BOUND.click.onDocDown)
            document.removeEventListener("pointerdown", BOUND.click.onDocDown);
        }
        if (BOUND.pan) {
          const container = document.getElementById("corner-canvas");
          if (container && BOUND.pan.onDown)
            container.removeEventListener("pointerdown", BOUND.pan.onDown);
        }
      } catch (_) {}

      try {
        const container = document.getElementById("corner-canvas");
        PIXI_APP = window.__PIXI_APP_GLOBAL;

        if (PIXI_APP) {
          console.info("[corner] Destruindo contexto WebGL do PIXI");

          // 1. Limpa o cache de texturas global
          if (PIXI.utils && PIXI.utils.clearTextureCache) {
            console.info("[corner] Limpando cache de texturas global");
            PIXI.utils.clearTextureCache();
          }

          // 2. Destr√≥i o world container recursivamente
          if (SCENE.world) {
            SCENE.world.destroy({
              children: true,
              texture: true,
              baseTexture: true,
            });
            SCENE.world = null;
          }

          // 3. Limpa atlas
          if (SCENE.atlas && SCENE.atlas.frames) {
            Object.values(SCENE.atlas.frames).forEach((tex) => {
              try {
                if (tex && tex.destroy) tex.destroy(true);
              } catch (e) {}
            });
            SCENE.atlas.frames = {};
          }

          // 4. Limpa items
          SCENE.items.clear();

          // 5. For√ßa a perda do contexto WebGL
          if (PIXI_APP.renderer && PIXI_APP.renderer.gl) {
            const gl = PIXI_APP.renderer.gl;
            const loseContext = gl.getExtension("WEBGL_lose_context");
            if (loseContext) {
              console.info("[corner] For√ßando perda de contexto WebGL");
              loseContext.loseContext();
            }
          }

          // 6. Remove o canvas do DOM
          if (PIXI_APP.view && PIXI_APP.view.parentNode) {
            PIXI_APP.view.parentNode.removeChild(PIXI_APP.view);
          }

          // 7. Destr√≥i a aplica√ß√£o
          PIXI_APP.destroy(true, {
            children: true,
            texture: true,
            baseTexture: true,
          });

          if (container) container.innerHTML = "";
        }
      } catch (e) {
        console.error("[corner] Erro ao destruir:", e);
      }

      PIXI_APP = null;
      window.__PIXI_APP_GLOBAL = null;
    }

    window.__CornerInstance = { destroy };

    // Limpa inst√¢ncia do PIXI quando navegar para outra p√°gina via HTMX
    const cleanupHandler = (evt) => {
      // Verifica se estamos saindo da p√°gina corner
      if (
        evt.detail &&
        evt.detail.pathInfo &&
        evt.detail.pathInfo.requestPath
      ) {
        const newPath = evt.detail.pathInfo.requestPath;
        if (!newPath.includes("/corner")) {
          console.info("[corner] Limpando PIXI antes de sair da p√°gina");
          if (window.__CornerInstance && window.__CornerInstance.destroy) {
            window.__CornerInstance.destroy();
          }
          // Remove o pr√≥prio handler
          document.removeEventListener("htmx:beforeRequest", cleanupHandler);
        }
      }
    };
    document.addEventListener("htmx:beforeRequest", cleanupHandler);

    // init now (scripts de p√°ginas htmx executam ap√≥s inser√ß√£o no DOM)
    ensurePixi();
    bindResize();
    bindWheelRotate();
    bindPan();
    bindOutsideClicks();
    bindHelpModal();
    // carregar itens do atlas (manifest)
    try {
      loadInventoryFromManifest();
    } catch {}

    // Invent√°rio din√¢mico (carrega manifest do atlas e liga intera√ß√µes)
    const search = document.getElementById("inventory-search");
    const groups = document.getElementById("inventory-groups");

    function renderInventoryGroups(data) {
      if (!groups) return;
      groups.innerHTML = "";
      const categories = Object.keys(data || {});
      categories.forEach((cat) => {
        const section = document.createElement("section");
        section.className =
          "inv-group border border-violet-700/30 rounded-lg overflow-hidden";
        section.innerHTML = `
          <button type="button" class="inv-toggle w-full flex items-center justify-between px-3 py-2 bg-white/5 hover:bg-white/10 text-left">
            <span class="flex items-center gap-2">
              <span class="font-medium text-violet-100">${cat}</span>
              <span class="inv-count text-xs text-violet-300"></span>
            </span>
            <span class="inv-chevron">‚ñæ</span>
          </button>
          <ul class="inv-items divide-y divide-violet-700/20"></ul>
        `;
        const ul = section.querySelector(".inv-items");
        (data[cat] || []).forEach((item) => {
          const li = document.createElement("li");
          li.className = "px-3 py-2 hover:bg-white/10 cursor-pointer";
          li.setAttribute("draggable", "true");
          li.setAttribute("data-key", item.key);
          li.textContent = item.label || item.key;
          ul.appendChild(li);
        });
        groups.appendChild(section);
      });
      bindInventoryInteractions();
      refreshGroupCounts();
    }

    async function loadInventoryFromManifest() {
      try {
        const res = await fetch("/public/assets/atlas/manifest.json", {
          cache: "no-store",
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const raw = await res.json();
        // Reescreve URLs antigas para o novo atlas
        const normalizeKey = (k) => {
          if (typeof k !== "string") return k;
          if (
            !/\.(png|jpg|jpeg|webp|gif|svg)$/i.test(k) &&
            !k.startsWith("/public/")
          )
            return k;
          let s = k.replace(/^\.\/?/, "");
          s = s.replace(/^public\//, "");
          // remove poss√≠veis prefixos antigos sem depender do nome da pasta
          s = s.replace(/^[^/]+\//, "");
          const fname = s.split("/").pop();
          return fname ? `/public/assets/atlas/${fname}` : k;
        };
        const data = {};
        Object.keys(raw || {}).forEach((cat) => {
          data[cat] = (raw[cat] || []).map((it) => ({
            label: it.label,
            key: normalizeKey(it.key),
          }));
        });
        renderInventoryGroups(data);
      } catch (e) {
        console.warn(
          "[corner] manifest do atlas n√£o encontrado, mantendo invent√°rio padr√£o."
        );
      }
    }

    function bindInventoryInteractions() {
      if (!groups) return;
      // toggle de grupos
      groups.querySelectorAll(".inv-group").forEach((grp) => {
        const btn = grp.querySelector(".inv-toggle");
        const ul = grp.querySelector(".inv-items");
        const chevron = grp.querySelector(".inv-chevron");
        // id est√°vel do grupo baseado no t√≠tulo
        const titleEl = btn && btn.querySelector("span.font-medium");
        const groupId =
          (titleEl &&
            (titleEl.textContent || "").toLowerCase().replace(/\s+/g, "-")) ||
          Math.random().toString(36).slice(2);
        grp.dataset.groupId = groupId;

        const storageKey = (id) => `inv_open_${id}`;
        const loadOpen = () => {
          try {
            const v = localStorage.getItem(storageKey(groupId));
            if (v === null) return true; // padr√£o: aberto
            return v === "1";
          } catch {
            return true;
          }
        };
        const saveOpen = (open) => {
          try {
            localStorage.setItem(storageKey(groupId), open ? "1" : "0");
          } catch {}
        };

        const setOpen = (open, persist = false) => {
          ul.style.display = open ? "" : "none";
          if (chevron) chevron.textContent = open ? "‚ñæ" : "‚ñ∏";
          grp.dataset.open = open ? "1" : "0";
          if (persist) saveOpen(open);
        };
        // estado inicial (persistido)
        setOpen(loadOpen());
        if (btn)
          btn.addEventListener("click", () => {
            const open = grp.dataset.open !== "0";
            setOpen(!open, true);
          });
      });
      // clique/drag/dblclick
      groups.querySelectorAll("[data-key]").forEach((li) => {
        // DRAG: iniciar arraste com dataTransfer
        li.addEventListener("dragstart", (ev) => {
          const key = li.getAttribute("data-key");
          try {
            ev.dataTransfer.setData("application/x-corner-item", key);
            ev.dataTransfer.setData("text/plain", key);
            ev.dataTransfer.effectAllowed = "copy";
          } catch {}
          DRAG_STATE.key = key;
        });
        li.addEventListener("dragend", () => {
          DRAG_STATE.key = null;
          hideGhost();
        });
        li.addEventListener("click", () => {
          const key = li.getAttribute("data-key");
          // destaque visual no invent√°rio
          groups.querySelectorAll("[data-key]").forEach((el) => {
            el.classList.toggle(
              "bg-white/10",
              el.getAttribute("data-key") === key
            );
          });
          // garantir grupo aberto
          const grp = li.closest(".inv-group");
          if (grp) {
            grp.style.display = "";
            const chevron = grp.querySelector(".inv-chevron");
            const ul = grp.querySelector(".inv-items");
            if (ul) ul.style.display = "";
            if (chevron) chevron.textContent = "‚ñæ";
            grp.dataset.open = "1";
            try {
              const gid = grp.dataset.groupId;
              if (gid) localStorage.setItem(`inv_open_${gid}`, "1");
            } catch {}
          }
        });
        // duplo clique: cria item no centro do canvas
        li.addEventListener("dblclick", async () => {
          const key = li.getAttribute("data-key");
          const container = document.getElementById("corner-canvas");
          if (!container) return;
          const rect = container.getBoundingClientRect();
          const px = rect.width / 2;
          const py = rect.height / 2;
          const local = SCENE.world
            ? SCENE.world.toLocal(new PIXI.Point(px, py))
            : new PIXI.Point(px, py);
          let best = { d: Infinity, gx: 0, gy: 0 };
          for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
            for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
              const { sx, sy } = HS_ISO.projectWorld(i, j);
              const dx = sx - local.x,
                dy = sy - local.y;
              const d = dx * dx + dy * dy;
              if (d < best.d) best = { d, gx: i, gy: j };
            }
          }
          // permitir posicionar nas bordas do canvas
          const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
          const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
          const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
          const xPct = gridToPct(gx);
          const yPct = gridToPct(gy);
          const CSRF =
            (document.querySelector('meta[name="csrf-token"]') || {}).content ||
            "";
          try {
            const res = await fetch("/corner/items", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRF-Token": CSRF,
                "HX-Request": "true",
              },
              body: JSON.stringify({ item_key: key, x: xPct, y: yPct }),
            });
            if (!res.ok) return;
            const html = await res.text();
            const node = htmlToNode(html);
            const data = domItemToData(node);
            data.x = xPct;
            data.y = yPct;
            try {
              window.__cornerItems = Array.isArray(window.__cornerItems)
                ? window.__cornerItems
                : [];
              window.__cornerItems.push(data);
            } catch {}
            addOrUpdateItem(data);
            selectItem(data.id);
            refreshGroupCounts();
          } catch (e) {
            console.error(e);
          }
        });
      });
    }
    if (search && groups) {
      const onInput = () => {
        const q = (search.value || "").trim().toLowerCase();
        groups.querySelectorAll(".inv-group").forEach((grp) => {
          const items = Array.from(grp.querySelectorAll("[data-key]"));
          let any = false;
          items.forEach((li) => {
            const txt = (li.textContent || "").toLowerCase();
            const show = !q || txt.includes(q);
            li.style.display = show ? "" : "none";
            if (show) any = true;
          });
          // esconde grupo sem matches
          grp.style.display = any ? "" : "none";
          // com busca ativa, abre grupos com resultados; sem busca, restaura estado salvo
          const btn = grp.querySelector(".inv-toggle");
          const ul = grp.querySelector(".inv-items");
          const chevron = grp.querySelector(".inv-chevron");
          const groupId = grp.dataset.groupId;
          const storageKey = (id) => `inv_open_${id}`;
          const setOpen = (open) => {
            ul.style.display = open ? "" : "none";
            if (chevron) chevron.textContent = open ? "‚ñæ" : "‚ñ∏";
            grp.dataset.open = open ? "1" : "0";
          };
          if (q) {
            setOpen(any); // abrir quando h√° resultado
          } else {
            try {
              const v = localStorage.getItem(storageKey(groupId));
              setOpen(v === null ? true : v === "1");
            } catch {
              setOpen(true);
            }
          }
        });
      };
      search.addEventListener("input", onInput);
    }

    // Atualiza contadores por grupo (quantidade de itens no canvas por categoria)
    function refreshGroupCounts() {
      if (!groups) return;
      const all = Array.isArray(window.__cornerItems)
        ? window.__cornerItems
        : [];
      groups.querySelectorAll(".inv-group").forEach((grp) => {
        const cnt = grp.querySelector(".inv-count");
        if (!cnt) return;
        const keys = Array.from(grp.querySelectorAll("[data-key]")).map((n) =>
          n.getAttribute("data-key")
        );
        let total = 0;
        all.forEach((it) => {
          if (keys.includes(String(it.item_key))) total += 1;
        });
        cnt.textContent = total > 0 ? `(${total})` : "";
      });
    }
    refreshGroupCounts();

    // Atualiza√ß√£o de contadores ocorre nas opera√ß√µes de criar/deletar

    // Drag & Drop no canvas: permitir soltar para criar item na posi√ß√£o
    (function enableCanvasDrop() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      container.addEventListener("dragover", (ev) => {
        // aceita c√≥pia
        try {
          ev.dataTransfer.dropEffect = "copy";
          const rect = container.getBoundingClientRect();
          let key = "";
          try {
            key =
              DRAG_STATE.key ||
              ev.dataTransfer.getData("application/x-corner-item") ||
              ev.dataTransfer.getData("text/plain") ||
              "";
          } catch {}
          if (key) {
            ensureGhost(key);
            updateGhostPosition(ev.clientX - rect.left, ev.clientY - rect.top);
          }
        } catch {}
        container.addEventListener("dragenter", (ev) => {
          const rect = container.getBoundingClientRect();
          let key = "";
          try {
            key =
              DRAG_STATE.key ||
              ev.dataTransfer.getData("application/x-corner-item") ||
              ev.dataTransfer.getData("text/plain") ||
              "";
          } catch {}
          if (key) {
            ensureGhost(key);
            updateGhostPosition(ev.clientX - rect.left, ev.clientY - rect.top);
          }
        });
        container.addEventListener("dragleave", (ev) => {
          // se saiu do canvas, esconder ghost
          const to = ev.relatedTarget;
          const leftCanvas = !(
            to &&
            (to === container || (to.closest && to.closest("#corner-canvas")))
          );
          if (leftCanvas) hideGhost();
        });
        ev.preventDefault();
      });
      container.addEventListener("drop", async (ev) => {
        ev.preventDefault();
        let key = "";
        try {
          key =
            ev.dataTransfer.getData("application/x-corner-item") ||
            ev.dataTransfer.getData("text/plain") ||
            "";
        } catch {}
        if (!key) return;
        // calcular posi√ß√£o em grid a partir do ponto solto
        const rect = container.getBoundingClientRect();
        const px = ev.clientX - rect.left;
        const py = ev.clientY - rect.top;
        // converter para coordenadas do mundo (compensa zoom/pan)
        const local = SCENE.world
          ? SCENE.world.toLocal(new PIXI.Point(px, py))
          : new PIXI.Point(px, py);
        // buscar o ponto de grade mais pr√≥ximo (com resolu√ß√£o 0.25)
        let best = { d: Infinity, gx: 0, gy: 0 };
        for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
          for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
            const { sx, sy } = HS_ISO.projectWorld(i, j);
            const dx = sx - local.x,
              dy = sy - local.y;
            const d = dx * dx + dy * dy;
            if (d < best.d) best = { d, gx: i, gy: j };
          }
        }
        // permitir posicionar nas bordas do canvas
        const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
        const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
        const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
        const xPct = gridToPct(gx);
        const yPct = gridToPct(gy);
        // criar item via POST /corner/items (hx-like)
        const CSRF =
          (document.querySelector('meta[name="csrf-token"]') || {}).content ||
          "";
        try {
          const res = await fetch("/corner/items", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": CSRF,
              "HX-Request": "true",
            },
            body: JSON.stringify({ item_key: key, x: xPct, y: yPct }),
          });
          if (!res.ok) return;
          const html = await res.text();
          const node = htmlToNode(html);
          const data = domItemToData(node);
          // manter x,y que acabamos de definir (o parcial j√° deve conter), mas garantimos
          data.x = xPct;
          data.y = yPct;
          // atualizar internamente
          try {
            window.__cornerItems = Array.isArray(window.__cornerItems)
              ? window.__cornerItems
              : [];
            window.__cornerItems.push(data);
          } catch {}
          addOrUpdateItem(data);
          selectItem(data.id);
          refreshGroupCounts();
        } catch (e) {
          console.error(e);
        }
        hideGhost();
      });
    })();
  })();
</script>
