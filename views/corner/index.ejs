<div class="space-y-6">
  <header class="flex items-center justify-between">
    <h1 class="text-2xl font-semibold text-violet-100">Nosso cantinho</h1>
    <form
      id="add-item-form"
      hx-post="/corner/items"
      hx-target="#corner-outbox"
      hx-swap="innerHTML"
      class="flex items-center gap-2"
    >
      <select
        name="item_key"
        class="bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100"
      >
        <optgroup label="Sof√°s">
          <option value="sofa">Sof√°</option>
        </optgroup>
        <optgroup label="Cadeiras">
          <option value="chair">Cadeira</option>
        </optgroup>
        <optgroup label="Mesas">
          <option value="table">Mesa</option>
        </optgroup>
        <optgroup label="Plantas">
          <option value="plant">Planta</option>
        </optgroup>
        <optgroup label="Ilumina√ß√£o">
          <option value="lamp">Lumin√°ria</option>
        </optgroup>
        <optgroup label="Eletr√¥nicos">
          <option value="tv">TV</option>
        </optgroup>
      </select>
      <button
        class="px-3 py-2 rounded bg-white/10 text-violet-100 hover:bg-white/20"
        type="submit"
      >
        Adicionar
      </button>

      <input type="hidden" name="_csrf" value="<%= csrfToken %>" />
    </form>
  </header>

  <div class="grid grid-cols-[1fr_280px] gap-6">
    <!-- Canvas do cantinho -->
    <section
      class="relative rounded-xl border border-violet-700/40 bg-white/5 overflow-hidden min-h-[420px]"
    >
      <div id="corner-canvas" class="absolute inset-0"></div>
      <!-- Toolbar de Zoom -->
      <div
        class="absolute top-2 left-2 z-30 flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md"
      >
        <button
          id="btn-zoom-out"
          class="px-2 py-1 hover:bg-white/10 rounded"
          title="Zoom out"
        >
          ‚àí
        </button>
        <button
          id="btn-zoom-reset"
          class="px-2 py-1 hover:bg-white/10 rounded text-xs"
          title="Resetar para 100%"
        >
          100%
        </button>
        <button
          id="btn-zoom-in"
          class="px-2 py-1 hover:bg-white/10 rounded"
          title="Zoom in"
        >
          +
        </button>
      </div>
      <!-- Overlay de a√ß√µes do item selecionado -->
      <div
        id="corner-overlay"
        class="absolute z-20 hidden"
        style="pointer-events: auto"
      >
        <div
          class="flex items-center gap-1 bg-black/40 text-violet-100 border border-violet-700/40 rounded-lg px-1.5 py-1 shadow-md"
        >
          <button
            id="btn-layer-down"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Enviar para tr√°s"
          >
            ‚§∫
          </button>
          <button
            id="btn-layer-up"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Trazer para frente"
          >
            ‚§ª
          </button>
          <button
            id="btn-layer-bottom"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Enviar para o fundo"
          >
            ‚§ì
          </button>
          <button
            id="btn-layer-top"
            class="px-2 py-1 hover:bg-white/10 rounded"
            title="Trazer para o topo"
          >
            ‚§í
          </button>
          <span class="mx-1 text-white/30">|</span>
          <label for="overlay-scale" class="sr-only">Escala</label>
          <input
            id="overlay-scale"
            type="number"
            step="0.05"
            min="0.25"
            max="2"
            value="1.0"
            class="w-20 bg-white/10 border border-violet-700/40 rounded px-1 py-0.5 text-violet-100 text-xs"
            title="Escala (0.25‚Äî2.0)"
          />
          <button
            id="btn-scale-dec"
            class="px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Escala -0.05"
          >
            ‚àí
          </button>
          <button
            id="btn-scale-inc"
            class="px-2 py-1 hover:bg-white/10 rounded text-xs"
            title="Escala +0.05"
          >
            +
          </button>
          <button
            id="btn-delete"
            class="px-2 py-1 bg-rose-600/80 hover:bg-rose-600 text-white rounded"
            title="Remover"
          >
            üóë
          </button>
        </div>
      </div>
      <div id="corner-outbox" class="hidden" aria-hidden="true"></div>
    </section>

    <!-- Invent√°rio -->
    <aside class="rounded-xl border border-violet-700/40 bg-white/5 p-3">
      <h2 class="text-lg text-violet-100 mb-3">Invent√°rio</h2>
      <div class="mb-3">
        <input
          id="inventory-search"
          type="text"
          class="w-full bg-white/5 border border-violet-700/40 rounded px-3 py-2 text-violet-100 placeholder-violet-300/60 focus:outline-none focus:ring-2 focus:ring-violet-500/50"
          placeholder="Buscar item..."
          autocomplete="off"
        />
      </div>
      <div
        id="inventory-groups"
        class="space-y-2 text-violet-200 text-sm"
      ></div>
      <p class="mt-4 text-xs text-violet-300/80">
        Dica: clique em um item para selecion√°-lo; d√™ duplo clique para
        adicionar imediatamente.
      </p>
    </aside>
  </div>
</div>

<!-- Dados iniciais para o Pixi (evita EJS direto no JS) -->
<script type="application/json" id="corner-items-data">
  <%- JSON.stringify(items || []) %>
</script>

<script src="https://unpkg.com/pixi.js@7.x/dist/pixi.min.js"></script>
<script src="https://unpkg.com/@pixi/unsafe-eval@7.x/dist/unsafe-eval.min.js"></script>
<script>
  // Dados iniciais vindos do servidor (via tag JSON)
  (function () {
    try {
      const el = document.getElementById("corner-items-data");
      window.__cornerItems = el ? JSON.parse(el.textContent || "[]") : [];
    } catch {
      window.__cornerItems = [];
    }
  })();
  // Isolar todo o c√≥digo da p√°gina em um controller para evitar redeclara√ß√µes em navega√ß√£o htmx
  (function CornerPage() {
    // Se j√° existe uma inst√¢ncia anterior, destr√≥i antes de inicializar
    if (
      window.__CornerInstance &&
      typeof window.__CornerInstance.destroy === "function"
    ) {
      try {
        window.__CornerInstance.destroy();
      } catch (_) {}
    }

    // Proje√ß√£o isom√©trica simples (escopo local)
    const HS_ISO = {
      gridN: 10,
      tileW: 72,
      tileH: 36,
      // origem fixa no espa√ßo do "world" (n√£o depende do container ap√≥s inicializar)
      originX: 0,
      originY: 0,
      sizes: {
        table: { w: 2, h: 1 },
        chair: { w: 1, h: 1 },
        plant: { w: 1, h: 1 },
        lamp: { w: 1, h: 1 },
        sofa: { w: 2, h: 1 },
        tv: { w: 2, h: 1 },
        // --- Isometric (Banheiro) ---
        "/public/furniture2/Isometric/bathroomCabinet_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/bathroomCabinetDrawer_SE.png": {
          w: 1,
          h: 1,
        },
        "/public/furniture2/Isometric/bathroomMirror_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/bathroomSink_SE.png": { w: 1, h: 1 },
        // --- Isometric (Sof√°s) ---
        "/public/furniture2/Isometric/loungeSofa_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/loungeSofaLong_SE.png": { w: 3, h: 1 },
        "/public/furniture2/Isometric/loungeSofaCorner_SE.png": { w: 2, h: 2 },
        "/public/furniture2/Isometric/loungeDesignSofa_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/loungeSofaOttoman_SE.png": { w: 1, h: 1 },
        // --- Isometric (Mesas) ---
        "/public/furniture2/Isometric/table_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/tableGlass_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/tableRound_SE.png": { w: 2, h: 2 },
        "/public/furniture2/Isometric/tableCoffee_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/tableCoffeeSquare_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/tableCoffeeGlass_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/sideTable_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/sideTableDrawers_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/desk_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/deskCorner_SE.png": { w: 2, h: 2 },
        "/public/furniture2/Isometric/bathroomSinkSquare_SE.png": {
          w: 1,
          h: 1,
        },
        "/public/furniture2/Isometric/bathtub_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/shower_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/showerRound_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/toilet_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/toiletSquare_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/trashcan_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/washer_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/dryer_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/washerDryerStacked_SE.png": {
          w: 1,
          h: 1,
        },
        // --- Isometric (Cadeiras/Bancos/Poltronas) ---
        "/public/furniture2/Isometric/chair_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/chairRounded_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/chairDesk_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/loungeChair_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/loungeChairRelax_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/loungeDesignChair_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/stoolBar_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/stoolBarSquare_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/bench_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/benchCushion_SE.png": { w: 2, h: 1 },
        // --- Isometric (Plantas) ---
        "/public/furniture2/Isometric/plantSmall1_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/plantSmall2_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/plantSmall3_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/pottedPlant_SE.png": { w: 1, h: 1 },
        // --- Isometric (Ilumina√ß√£o) ---
        "/public/furniture2/Isometric/lampRoundFloor_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/lampRoundTable_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/lampSquareFloor_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/lampSquareTable_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/lampWall_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/lampSquareCeiling_SE.png": { w: 1, h: 1 },
        // --- Isometric (Eletr√¥nicos) ---
        "/public/furniture2/Isometric/televisionModern_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/televisionVintage_SE.png": { w: 2, h: 1 },
        "/public/furniture2/Isometric/televisionAntenna_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/computerScreen_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/laptop_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/speaker_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/speakerSmall_SE.png": { w: 1, h: 1 },
        "/public/furniture2/Isometric/radio_SE.png": { w: 1, h: 1 },
      },
      // Define a origem no espa√ßo do world, centralizando a grade inicialmente
      computeOrigin(container) {
        const { tileH, gridN } = this;
        const cw = container.clientWidth || 800;
        const ch = container.clientHeight || 420;
        const gridPixelH = gridN * tileH;
        this.originX = cw / 2;
        this.originY = Math.max(24, (ch - gridPixelH) / 2) + tileH;
      },
      // Projeta coordenadas de grade para coordenadas locais do world
      projectWorld(gx, gy) {
        const { tileW, tileH, originX, originY } = this;
        const sx = originX + (gx - gy) * (tileW / 2);
        const sy = originY + (gx + gy) * (tileH / 2);
        return { sx, sy };
      },
    };

    // ===== Implementa√ß√£o Pixi =====
    let PIXI_APP = null;
    const SCENE = {
      items: new Map(),
      selectedId: null,
      world: null,
      zoom: 1,
      spaceDown: false,
      pan: { active: false },
      floor: null,
      ghost: null,
    };
    // estado de drag global para invent√°rio -> canvas
    const DRAG_STATE = { key: null };
    const BOUND = {
      resize: null,
      keydown: null,
      keyup: null,
      htmx: null,
      click: null,
      pan: null,
    };

    function pctToGrid(p) {
      // Converte porcentagem para √≠ndice de grade com resolu√ß√£o de 0.25
      const step = 100 / (HS_ISO.gridN - 1);
      const gi = (Number(p) || 0) / step; // pode ser fracion√°rio
      // arredonda para o m√∫ltiplo de 0.25 mais pr√≥ximo
      const g025 = Math.round(gi * 4) / 4;
      return Math.max(0, Math.min(HS_ISO.gridN - 1, g025));
    }
    function gridToPct(g) {
      // Converte √≠ndice de grade (pode ter .5) para porcentagem sem arredondar
      const step = 100 / (HS_ISO.gridN - 1);
      const val = (Number(g) || 0) * step;
      // limita a duas casas decimais para estabilidade de rede/render
      return Math.max(0, Math.min(100, Number(val.toFixed(2))));
    }
    function domItemToData(node) {
      return {
        id: Number(node.getAttribute("data-id")),
        item_key: node.getAttribute("data-key") || "unknown",
        x: Number(node.getAttribute("data-x") || 50),
        y: Number(node.getAttribute("data-y") || 50),
        z: Number(node.getAttribute("data-z") || 0),
        rotation: Number(node.getAttribute("data-rot") || 0),
        tilt_x: Number(node.getAttribute("data-tilt-x") || 0),
        tilt_y: Number(node.getAttribute("data-tilt-y") || 0),
        flip_x: Number(node.getAttribute("data-flip-x") || 0) ? 1 : 0,
        flip_y: Number(node.getAttribute("data-flip-y") || 0) ? 1 : 0,
        scale: Number(node.getAttribute("data-scale") || 1.0),
        layer: Number(node.getAttribute("data-layer") || 0),
      };
    }

    async function loadAtlasIfAny() {
      const ATLAS = { ready: false, frames: {} };
      try {
        const res = await fetch("/public/assets/atlas/items.json", {
          cache: "no-store",
        });
        if (!res.ok) return ATLAS;
        const data = await res.json();
        // Caso 1: j√° veio pronto de Assets como spritesheet com .textures
        if (data && data.textures && typeof data.textures === "object") {
          ATLAS.ready = true;
          ATLAS.frames = data.textures;
          console.info("[corner] Atlas carregado (textures)");
          return ATLAS;
        }
        // Caso 2: mapa simples de imagens: { images: { key: url } }
        if (data && data.images && typeof data.images === "object") {
          const frames = {};
          // Carrega data: URIs manualmente em elementos Image para evitar fetch/GET inv√°lido
          for (const [k, url] of Object.entries(data.images)) {
            try {
              if (typeof url === "string" && url.startsWith("data:")) {
                const img = new Image();
                img.src = url;
                // decode() garante que a imagem est√° pronta
                if (img.decode) {
                  await img.decode();
                } else {
                  await new Promise((resolve) => {
                    img.onload = () => resolve();
                    img.onerror = () => resolve();
                  });
                }
                const base = PIXI.BaseTexture.from(img);
                frames[k] = new PIXI.Texture(base);
              } else {
                frames[k] = PIXI.Texture.from(url);
              }
            } catch (_) {
              // fallback simples para evitar quebra total
              frames[k] = PIXI.Texture.WHITE;
            }
          }
          ATLAS.ready = true;
          ATLAS.frames = frames;
          console.info("[corner] Atlas carregado (images map)");
          return ATLAS;
        }
        // Caso 3: TexturePacker style { frames, meta: { image } }
        if (data && data.frames && data.meta && data.meta.image) {
          let base;
          if (
            typeof data.meta.image === "string" &&
            data.meta.image.startsWith("data:")
          ) {
            const img = new Image();
            img.src = data.meta.image;
            if (img.decode) {
              await img.decode();
            } else {
              await new Promise((resolve) => {
                img.onload = () => resolve();
                img.onerror = () => resolve();
              });
            }
            base = PIXI.BaseTexture.from(img);
          } else {
            base = PIXI.BaseTexture.from(data.meta.image);
          }
          const ss = new PIXI.Spritesheet(base, data);
          await ss.parse();
          ATLAS.ready = true;
          ATLAS.frames = ss.textures;
          console.info("[corner] Atlas carregado (TexturePacker)");
          return ATLAS;
        }
      } catch (_) {
        // Sem atlas: usa SVG inline
      }
      return ATLAS;
    }

    async function ensurePixi(force = false) {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      if (PIXI_APP && !force) return;
      if (PIXI_APP && force) {
        PIXI_APP.destroy(true, {
          children: true,
          texture: true,
          baseTexture: true,
        });
        PIXI_APP = null;
      }

      PIXI_APP = new PIXI.Application({
        backgroundAlpha: 0,
        resizeTo: container,
        antialias: true,
      });
      container.innerHTML = "";
      container.appendChild(PIXI_APP.view);

      // container raiz do mundo para permitir zoom/pan
      SCENE.world = new PIXI.Container();
      SCENE.world.sortableChildren = true;
      PIXI_APP.stage.addChild(SCENE.world);

      // origem fixa do mundo para proje√ß√£o est√°vel
      HS_ISO.computeOrigin(container);
      drawFloor(SCENE.world);
      SCENE.items.clear();
      SCENE.atlas = await loadAtlasIfAny();
      (window.__cornerItems || []).forEach(addOrUpdateItem);

      // teclado (inclui Space para pan)
      const containerEl = document.getElementById("corner-canvas");
      BOUND.keydown = (ev) => {
        // ignora quando digitando em inputs
        const t = ev.target;
        const tag = (t && t.tagName) || "";
        const editing =
          tag === "INPUT" || tag === "TEXTAREA" || (t && t.isContentEditable);
        if (ev.code === "Space" && !editing) {
          if (!SCENE.spaceDown) {
            SCENE.spaceDown = true;
            if (containerEl) containerEl.style.cursor = "grab";
          }
          ev.preventDefault();
          return;
        }
        onKey(ev);
      };
      BOUND.keyup = (ev) => {
        if (ev.code === "Space") {
          SCENE.spaceDown = false;
          const el = document.getElementById("corner-canvas");
          // mant√©m 'grabbing' caso ainda esteja arrastando; sen√£o limpa
          if (el && !(SCENE.pan && SCENE.pan.active)) el.style.cursor = "";
        }
      };
      window.addEventListener("keydown", BOUND.keydown);
      window.addEventListener("keyup", BOUND.keyup);

      // zoom toolbar
      const btnIn = document.getElementById("btn-zoom-in");
      const btnOut = document.getElementById("btn-zoom-out");
      const btnReset = document.getElementById("btn-zoom-reset");
      if (btnIn) btnIn.onclick = () => setZoom((SCENE.zoom || 1) + 0.1);
      if (btnOut) btnOut.onclick = () => setZoom((SCENE.zoom || 1) - 0.1);
      if (btnReset) btnReset.onclick = () => setZoom(1);
    }

    function setZoom(value) {
      const container = document.getElementById("corner-canvas");
      if (!SCENE.world || !container) return;
      const rect = container.getBoundingClientRect();
      const mx = rect.width / 2;
      const my = rect.height / 2;
      const next = Math.max(0.6, Math.min(2.0, Number(value) || 1));
      const local = SCENE.world.toLocal(new PIXI.Point(mx, my));
      SCENE.world.pivot.set(local.x, local.y);
      SCENE.world.position.set(mx, my);
      SCENE.world.scale.set(next);
      SCENE.zoom = next;
      if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
    }

    function drawFloor(stage) {
      // limpa floor anterior
      if (SCENE.floor) {
        try {
          SCENE.floor.destroy({ children: true });
        } catch (_) {}
      }
      SCENE.floor = new PIXI.Container();
      const g = new PIXI.Container();
      const { gridN, tileW, tileH } = HS_ISO;
      for (let i = 0; i < gridN; i++) {
        for (let j = 0; j < gridN; j++) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const diamond = new PIXI.Graphics();
          diamond.lineStyle(1, 0x7c3aed, 0.18);
          diamond.beginFill(0x7c3aed, 0.1);
          const w = tileW,
            h = tileH;
          diamond.drawPolygon([
            sx,
            sy - h / 2,
            sx + w / 2,
            sy,
            sx,
            sy + h / 2,
            sx - w / 2,
            sy,
          ]);
          diamond.endFill();
          g.addChild(diamond);
        }
      }
      SCENE.floor.addChild(g);
      stage.addChild(SCENE.floor);
    }

    function textureFromUrl(url) {
      try {
        if (typeof url === "string" && url.startsWith("data:")) {
          const img = new Image();
          img.src = url;
          const base = PIXI.BaseTexture.from(img);
          return new PIXI.Texture(base);
        }
      } catch (_) {}
      return PIXI.Texture.from(url);
    }

    function spriteFor(item) {
      const c = new PIXI.Container();
      const textures = {
        table: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='8' y='24' width='48' height='16' rx='4' fill='%23c4b5fd'/><rect x='12' y='40' width='8' height='12' fill='%239b87f5'/><rect x='44' y='40' width='8' height='12' fill='%239b87f5'/></svg>`,
        chair: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><rect x='20' y='20' width='24' height='12' rx='3' fill='%23f0abfc'/><rect x='18' y='32' width='28' height='10' rx='3' fill='%23d946ef'/><rect x='22' y='42' width='6' height='12' fill='%239b87f5'/><rect x='36' y='42' width='6' height='12' fill='%239b87f5'/></svg>`,
        plant: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='18' r='8' fill='%234ade80'/><path d='M32 26v24' stroke='%230a0a0a' stroke-width='3'/><rect x='22' y='42' width='20' height='12' rx='2' fill='%238b5cf6'/></svg>`,
        lamp: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><polygon points='20,18 44,18 38,8 26,8' fill='%23fde68a'/><rect x='30' y='18' width='4' height='26' fill='%239b87f5'/><rect x='24' y='44' width='16' height='6' rx='2' fill='%237c3aed'/></svg>`,
        sofa: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='8' y='26' width='80' height='22' rx='6' fill='%23a78bfa'/><rect x='8' y='16' width='80' height='14' rx='6' fill='%23c4b5fd'/><rect x='12' y='48' width='10' height='6' fill='%239b87f5'/><rect x='74' y='48' width='10' height='6' fill='%239b87f5'/></svg>`,
        tv: `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='96' height='64'><rect x='10' y='8' width='76' height='46' rx='6' fill='%230a0a0a'/><rect x='14' y='12' width='68' height='38' rx='4' fill='%23252525'/><rect x='40' y='54' width='16' height='4' fill='%237c3aed'/></svg>`,
      };
      let tex = null;
      if (SCENE.atlas && SCENE.atlas.ready) {
        const key = item.item_key;
        const candidates = [key, `${key}.png`, `${key}.webp`, `${key}.jpg`];
        for (const k of candidates) {
          if (SCENE.atlas.frames[k]) {
            tex = SCENE.atlas.frames[k];
            break;
          }
        }
      }
      if (!tex) {
        // suportar item_key como caminho/URL de imagem
        const key = String(item.item_key || "");
        const looksLikeImg =
          /\.(png|jpg|jpeg|webp|gif)$/i.test(key) || key.startsWith("/public/");
        const url = looksLikeImg
          ? key
          : textures[item.item_key] ||
            `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='10' fill='%23a78bfa'/></svg>`;
        tex = textureFromUrl(url);
      }
      const spr = new PIXI.Sprite(tex);
      spr.anchor.set(0.5);
      const baseScale =
        item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
      const userScale = Number(item.scale || 1.0);
      spr.scale.set(baseScale * userScale);
      const shadow = new PIXI.Graphics();
      shadow.beginFill(0x000000, 0.18);
      shadow.drawEllipse(0, 18, 14, 4);
      shadow.endFill();
      shadow.zIndex = -1;
      c.addChild(shadow, spr);
      c.hsSpr = spr; // refer√™ncia ao sprite principal
      c.eventMode = "static";
      c.cursor = "pointer";
      return c;
    }

    // ===== Ghost (preview durante drag) =====
    function hideGhost() {
      if (SCENE.ghost && SCENE.ghost.container) {
        try {
          SCENE.ghost.container.destroy({ children: true });
        } catch (_) {}
      }
      SCENE.ghost = null;
    }
    function ensureGhost(key) {
      if (SCENE.ghost && SCENE.ghost.key === key && SCENE.ghost.container)
        return SCENE.ghost.container;
      // recria ghost
      hideGhost();
      const item = {
        item_key: key,
        scale: 1.0,
        rotation: 0,
        z: 0,
        tilt_x: 0,
        tilt_y: 0,
        flip_x: 0,
        flip_y: 0,
      };
      const cont = spriteFor(item);
      cont.alpha = 0.6;
      cont.eventMode = "none";
      // esconder sombra do ghost
      cont.children.forEach((ch) => {
        if (ch && ch.constructor && ch.constructor.name === "Graphics")
          ch.visible = false;
      });
      cont.zIndex = 100000;
      if (SCENE.world) {
        SCENE.world.addChild(cont);
        SCENE.world.sortChildren();
      }
      SCENE.ghost = { key, container: cont };
      return cont;
    }
    function updateGhostPosition(px, py) {
      if (!SCENE.world || !SCENE.ghost || !SCENE.ghost.container) return;
      const ptLocal = SCENE.world.toLocal(new PIXI.Point(px, py));
      let best = { d: Infinity, gx: 0, gy: 0 };
      for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
        for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const dx = sx - ptLocal.x,
            dy = sy - ptLocal.y;
          const d = dx * dx + dy * dy;
          if (d < best.d) best = { d, gx: i, gy: j };
        }
      }
      // clamp at√© as bordas da grade (permitir borda do canvas)
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
      const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
      const { sx, sy } = HS_ISO.projectWorld(gx, gy);
      SCENE.ghost.container.x = sx;
      SCENE.ghost.container.y = sy;
    }

    function addOrUpdateItem(item) {
      const container = document.getElementById("corner-canvas");
      const { sx, sy } = HS_ISO.projectWorld(
        pctToGrid(item.x),
        pctToGrid(item.y)
      );
      const sy3d = sy - item.z * (HS_ISO.tileH / 2);
      let entry = SCENE.items.get(item.id);
      if (!entry) {
        const sprite = spriteFor(item);
        sprite.x = sx;
        sprite.y = sy3d;
        sprite.rotation = ((item.rotation || 0) * Math.PI) / 180;
        sprite.alpha = 0.98;
        // aplica escala do usu√°rio
        const base =
          item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
        const scl = Number(item.scale || 1.0);
        if (sprite.hsSpr) {
          const sx = (item.flip_x ? -1 : 1) * base * scl;
          const sy = (item.flip_y ? -1 : 1) * base * scl;
          sprite.hsSpr.scale.set(sx, sy);
          const kx = Number(item.tilt_x || 0) * (Math.PI / 180);
          const ky = Number(item.tilt_y || 0) * (Math.PI / 180);
          sprite.hsSpr.skew.set(kx, ky);
        }
        sprite.on("pointerdown", (e) => {
          // Evita que o clique no sprite limpe a sele√ß√£o via handler global
          SCENE.justClickedSprite = true;
          setTimeout(() => (SCENE.justClickedSprite = false), 0);
          startDrag(item.id, e);
        });
        sprite.on("pointertap", () => selectItem(item.id));
        SCENE.world.addChild(sprite);
        entry = { item: { ...item }, sprite };
        SCENE.items.set(item.id, entry);
      } else {
        entry.item = { ...item };
        entry.sprite.x = sx;
        entry.sprite.y = sy3d;
        entry.sprite.rotation = ((item.rotation || 0) * Math.PI) / 180;
        const base =
          item.item_key === "sofa" || item.item_key === "tv" ? 0.75 : 0.6;
        const scl = Number(item.scale || 1.0);
        if (entry.sprite.hsSpr) {
          const sx = (item.flip_x ? -1 : 1) * base * scl;
          const sy = (item.flip_y ? -1 : 1) * base * scl;
          entry.sprite.hsSpr.scale.set(sx, sy);
          const kx = Number(item.tilt_x || 0) * (Math.PI / 180);
          const ky = Number(item.tilt_y || 0) * (Math.PI / 180);
          entry.sprite.hsSpr.skew.set(kx, ky);
        }
      }
      sortByDepth();
    }

    function sortByDepth() {
      const arr = Array.from(SCENE.items.values());
      arr.sort((a, b) => {
        const la = Number(a.item.layer || 0);
        const lb = Number(b.item.layer || 0);
        if (la !== lb) return la - lb; // layer menor fica atr√°s
        return a.sprite.y - b.sprite.y; // empate: usa profundidade isom√©trica
      });
      arr.forEach((e, i) => (e.sprite.zIndex = 100 + i));
      if (SCENE.world) SCENE.world.sortChildren();
    }

    let DRAG = null;
    function startDrag(id, e) {
      selectItem(id);
      DRAG = { id };
      const up = () => {
        if (!DRAG) return;
        finishDrag();
        window.removeEventListener("pointerup", up);
        window.removeEventListener("pointermove", move);
      };
      const move = (ev) => dragMove(ev);
      window.addEventListener("pointerup", up);
      window.addEventListener("pointermove", move);
    }
    function dragMove(ev) {
      if (!DRAG) return;
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) return;
      const container = document.getElementById("corner-canvas");
      const rect = container.getBoundingClientRect();
      const px = ev.clientX - rect.left;
      const py = ev.clientY - rect.top;
      // converte para coordenadas do mundo (compensa zoom/pan)
      const ptLocal = SCENE.world
        ? SCENE.world.toLocal(new PIXI.Point(px, py))
        : new PIXI.Point(px, py);
      let best = { d: Infinity, gx: 0, gy: 0, sx: 0, sy: 0 };
      for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
        for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
          const { sx, sy } = HS_ISO.projectWorld(i, j);
          const sy3d = sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
          const dx = sx - ptLocal.x,
            dy = sy3d - ptLocal.y;
          const d = dx * dx + dy * dy;
          if (d < best.d) best = { d, gx: i, gy: j, sx, sy: sy3d };
        }
      }
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
      const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
      const p = HS_ISO.projectWorld(gx, gy);
      const sy3d = p.sy - (entry.item.z || 0) * (HS_ISO.tileH / 2);
      entry.sprite.x = p.sx;
      entry.sprite.y = sy3d;
      DRAG.gx = gx;
      DRAG.gy = gy;
      if (SCENE.selectedId === DRAG.id) updateOverlayPosition(DRAG.id);
    }
    async function finishDrag() {
      const entry = SCENE.items.get(DRAG.id);
      if (!entry) {
        DRAG = null;
        return;
      }
      const xPct = gridToPct(DRAG.gx);
      const yPct = gridToPct(DRAG.gy);
      const ok = await savePosition(DRAG.id, xPct, yPct);
      if (ok) {
        entry.item.x = xPct;
        entry.item.y = yPct;
      }
      sortByDepth();
      DRAG = null;
    }

    function selectItem(id) {
      SCENE.selectedId = id;
      SCENE.items.forEach(({ sprite }, key) => {
        sprite.scale.set(key === id ? 1.06 : 1.0);
      });
      updateOverlayPosition(id);
      bindOverlayActions(id);
    }

    function updateOverlayPosition(id) {
      const entry = SCENE.items.get(id);
      const overlay = document.getElementById("corner-overlay");
      const container = document.getElementById("corner-canvas");
      if (!entry || !overlay || !container) return;
      overlay.classList.remove("hidden");
      const gap = 8;
      // posi√ß√£o global do sprite (considera zoom/pan)
      const gp = entry.sprite.getGlobalPosition();
      const px = Math.round(gp.x);
      const py = Math.round(gp.y);
      // remover transform para medir corretamente
      overlay.style.transform = "none";
      // for√ßa c√°lculo de dimens√µes
      const w = overlay.offsetWidth || 160;
      const h = overlay.offsetHeight || 32;
      const cw = container.clientWidth || 0;
      const ch = container.clientHeight || 0;
      // preferir acima
      let left = Math.round(px - w / 2);
      let top = Math.round(py - (h + gap));
      // se n√£o couber acima, coloca abaixo
      if (top < 4) top = Math.round(py + gap);
      // clamp para dentro do canvas
      const minX = 4;
      const minY = 4;
      const maxX = Math.max(minX, cw - w - 4);
      const maxY = Math.max(minY, ch - h - 4);
      left = Math.max(minX, Math.min(maxX, left));
      top = Math.max(minY, Math.min(maxY, top));
      overlay.style.left = left + "px";
      overlay.style.top = top + "px";
      updateOverlayRotationDisplay(id);
      updateOverlayScaleDisplay(id);
    }

    function updateOverlayRotationDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const span = document.getElementById("overlay-rot");
        if (!entry || !span) return;
        const rot = Math.round(entry.item.rotation || 0) % 360;
        span.textContent = `${rot}¬∞`;
      } catch (_) {}
    }

    function updateOverlayScaleDisplay(id) {
      try {
        const entry = SCENE.items.get(id);
        const input = document.getElementById("overlay-scale");
        if (!entry || !input) return;
        input.value = Number(entry.item.scale || 1.0).toFixed(2);
      } catch (_) {}
    }

    function bindOverlayActions(id) {
      const overlay = document.getElementById("corner-overlay");
      if (!overlay) return;
      const idSel = id;
      const btnDel = document.getElementById("btn-delete");
      const btnLU = document.getElementById("btn-layer-up");
      const btnLD = document.getElementById("btn-layer-down");
      const btnLT = document.getElementById("btn-layer-top");
      const btnLB = document.getElementById("btn-layer-bottom");
      if (btnDel)
        btnDel.onclick = async (e) => {
          e.stopPropagation();
          await deleteItem(idSel);
          overlay.classList.add("hidden");
        };
      // bot√µes de rota√ß√£o e altura removidos do overlay

      function layerBounds() {
        let min = 0,
          max = 0;
        SCENE.items.forEach(({ item }) => {
          const l = Number(item.layer || 0);
          if (l < min) min = l;
          if (l > max) max = l;
        });
        return { min, max };
      }
      if (btnLU)
        btnLU.onclick = async (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            const { max } = layerBounds();
            await saveLayer(idSel, max + 1);
          } else {
            await saveStack(idSel, +1);
          }
        };
      if (btnLD)
        btnLD.onclick = async (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            const { min } = layerBounds();
            await saveLayer(idSel, min - 1);
          } else {
            await saveStack(idSel, -1);
          }
        };
      if (btnLT)
        btnLT.onclick = async (e) => {
          e.stopPropagation();
          const { max } = layerBounds();
          await saveLayer(idSel, max + 1);
        };
      if (btnLB)
        btnLB.onclick = async (e) => {
          e.stopPropagation();
          const { min } = layerBounds();
          await saveLayer(idSel, min - 1);
        };

      const inputScale = document.getElementById("overlay-scale");
      const btnInc = document.getElementById("btn-scale-inc");
      const btnDec = document.getElementById("btn-scale-dec");
      async function setScale(val) {
        const scl = Math.max(0.25, Math.min(2.0, Number(val) || 1.0));
        await saveScale(idSel, scl);
        updateOverlayScaleDisplay(idSel);
      }
      if (inputScale) {
        inputScale.onchange = async (e) => {
          e.stopPropagation();
          await setScale(inputScale.value);
        };
      }
      if (btnInc)
        btnInc.onclick = async (e) => {
          e.stopPropagation();
          const v = Number((Number(inputScale.value || 1) + 0.05).toFixed(2));
          await setScale(v);
        };
      if (btnDec)
        btnDec.onclick = async (e) => {
          e.stopPropagation();
          const v = Number((Number(inputScale.value || 1) - 0.05).toFixed(2));
          await setScale(v);
        };
    }

    function clearSelection() {
      SCENE.selectedId = null;
      const overlay = document.getElementById("corner-overlay");
      if (overlay) overlay.classList.add("hidden");
      SCENE.items.forEach(({ sprite }) => sprite.scale.set(1.0));
    }

    function bindOutsideClicks() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      const onCanvasDown = (ev) => {
        if (SCENE.justClickedSprite) return;
        // n√£o limpar sele√ß√£o quando iniciar pan (bot√£o do meio ou Space+esquerdo)
        if (ev && (ev.button === 1 || (ev.button === 0 && SCENE.spaceDown)))
          return;
        clearSelection();
      };
      container.addEventListener("pointerdown", onCanvasDown);

      const onDocDown = (ev) => {
        const overlay = document.getElementById("corner-overlay");
        if (overlay && overlay.contains(ev.target)) return;
        const insideCanvas =
          ev.target.closest && ev.target.closest("#corner-canvas");
        if (!insideCanvas) clearSelection();
      };
      document.addEventListener("pointerdown", onDocDown);
      BOUND.click = { onCanvasDown, onDocDown };
    }

    // Pan do canvas (bot√£o do meio ou Space + arrastar com esquerdo)
    function bindPan() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      const onDown = (ev) => {
        const wantPan = ev.button === 1 || (ev.button === 0 && SCENE.spaceDown);
        if (!wantPan) return;
        ev.preventDefault();
        SCENE.pan = SCENE.pan || {};
        SCENE.pan.active = true;
        SCENE.pan.startX = ev.clientX;
        SCENE.pan.startY = ev.clientY;
        SCENE.pan.worldX = SCENE.world ? SCENE.world.position.x : 0;
        SCENE.pan.worldY = SCENE.world ? SCENE.world.position.y : 0;
        container.style.cursor = "grabbing";
        const onMove = (e) => {
          if (!SCENE.pan.active || !SCENE.world) return;
          const dx = e.clientX - SCENE.pan.startX;
          const dy = e.clientY - SCENE.pan.startY;
          SCENE.world.position.set(
            SCENE.pan.worldX + dx,
            SCENE.pan.worldY + dy
          );
          if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
        };
        const onUp = () => {
          SCENE.pan.active = false;
          // se Space ainda est√° segurado, volta para 'grab'; sen√£o limpa
          container.style.cursor = SCENE.spaceDown ? "grab" : "";
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", onUp);
        };
        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onUp);
      };
      container.addEventListener("pointerdown", onDown);
      BOUND.pan = { onDown };
    }

    async function saveStack(id, dir) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/stack`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dir }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function savePosition(id, x, y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/position`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ x, y }),
        });
        return res.ok;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveNudge(id, dx = 0, dy = 0, drot = 0) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/nudge`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dx, dy, drot }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveHeight(id, dz) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/height`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ dz }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    async function saveScale(id, scale) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/scale`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ scale }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveTilt(id, tilt_x, tilt_y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/tilt`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ tilt_x, tilt_y }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveFlip(id, flip_x, flip_y) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/flip`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ flip_x, flip_y }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function saveLayer(id, layer) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/layer`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": CSRF,
            "HX-Request": "true",
          },
          body: JSON.stringify({ layer }),
        });
        if (!res.ok) return false;
        const html = await res.text();
        const node = htmlToNode(html);
        const data = domItemToData(node);
        addOrUpdateItem(data);
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }
    async function deleteItem(id) {
      const CSRF =
        (document.querySelector('meta[name="csrf-token"]') || {}).content || "";
      try {
        const res = await fetch(`/corner/items/${id}/delete`, {
          method: "POST",
          headers: { "X-CSRF-Token": CSRF, "HX-Request": "true" },
        });
        if (!res.ok) return false;
        removeSprite(id);
        // remove do cache local e atualiza contadores
        try {
          if (Array.isArray(window.__cornerItems)) {
            window.__cornerItems = window.__cornerItems.filter(
              (it) => it.id !== id
            );
          }
        } catch {}
        try {
          refreshGroupCounts && refreshGroupCounts();
        } catch {}
        return true;
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    function htmlToNode(html) {
      const t = document.createElement("div");
      t.innerHTML = html.trim();
      return t.firstElementChild;
    }
    function removeSprite(id) {
      const e = SCENE.items.get(id);
      if (!e) return;
      e.sprite.destroy({ children: true });
      SCENE.items.delete(id);
    }

    // resize handler
    function bindResize() {
      BOUND.resize = () => {
        if (!PIXI_APP) return;
        const container = document.getElementById("corner-canvas");
        if (container) HS_ISO.computeOrigin(container);
        drawFloor(SCENE.world);
        SCENE.items.forEach(({ item }) => addOrUpdateItem(item));
        if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
      };
      window.addEventListener("resize", BOUND.resize);
    }

    // Integra√ß√£o com htmx (listener removido no destroy)
    function bindHtmx() {
      BOUND.htmx = (e) => {
        const target = e && e.detail && e.detail.target;
        if (target && target.id === "corner-outbox") {
          const node = target.querySelector(".corner-item");
          if (node) {
            const item = domItemToData(node);
            try {
              window.__cornerItems = Array.isArray(window.__cornerItems)
                ? window.__cornerItems
                : [];
              window.__cornerItems.push(item);
            } catch (_) {}
            addOrUpdateItem(item);
            selectItem(item.id);
            target.innerHTML = "";
          }
        }
      };
      document.addEventListener("htmx:afterSwap", BOUND.htmx);
    }

    // Teclado
    async function onKey(ev) {
      // n√£o interferir quando digitando em inputs
      const t = ev.target;
      const tag = (t && t.tagName) || "";
      if (tag === "INPUT" || tag === "TEXTAREA" || (t && t.isContentEditable))
        return;
      if (!SCENE.selectedId) return;
      const id = SCENE.selectedId;
      const entry = SCENE.items.get(id);
      if (!entry) return;
      // Removido: movimenta√ß√£o por setas
      if (ev.key.toLowerCase() === "q") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, -15);
        updateOverlayRotationDisplay(id);
      } else if (ev.key.toLowerCase() === "e") {
        ev.preventDefault();
        await saveNudge(id, 0, 0, 15);
        updateOverlayRotationDisplay(id);
      } else if (ev.key.toLowerCase() === "t") {
        // tilt X - inclina√ß√£o no eixo X (skew Y)
        ev.preventDefault();
        const tx = Number(entry.item.tilt_x || 0) - 2;
        await saveTilt(id, tx, entry.item.tilt_y || 0);
      } else if (ev.key.toLowerCase() === "g") {
        ev.preventDefault();
        const tx = Number(entry.item.tilt_x || 0) + 2;
        await saveTilt(id, tx, entry.item.tilt_y || 0);
      } else if (ev.key.toLowerCase() === "y") {
        // tilt Y - inclina√ß√£o no eixo Y (skew X)
        ev.preventDefault();
        const ty = Number(entry.item.tilt_y || 0) - 2;
        await saveTilt(id, entry.item.tilt_x || 0, ty);
      } else if (ev.key.toLowerCase() === "h") {
        ev.preventDefault();
        const ty = Number(entry.item.tilt_y || 0) + 2;
        await saveTilt(id, entry.item.tilt_x || 0, ty);
      } else if (ev.key.toLowerCase() === "f") {
        // flip horizontal
        ev.preventDefault();
        const fx = entry.item.flip_x ? 0 : 1;
        await saveFlip(id, fx, entry.item.flip_y || 0);
      } else if (ev.key.toLowerCase() === "v") {
        // flip vertical
        ev.preventDefault();
        const fy = entry.item.flip_y ? 0 : 1;
        await saveFlip(id, entry.item.flip_x || 0, fy);
      } else if (
        (ev.ctrlKey || ev.metaKey) &&
        (ev.key === "=" || ev.key === "+")
      ) {
        // Prioriza escala com Ctrl/Cmd +
        ev.preventDefault();
        const cur = Number(entry.item.scale || 1.0);
        await saveScale(id, Math.min(2.0, Number((cur + 0.05).toFixed(2))));
      } else if ((ev.ctrlKey || ev.metaKey) && ev.key === "-") {
        // Prioriza escala com Ctrl/Cmd -
        ev.preventDefault();
        const cur = Number(entry.item.scale || 1.0);
        await saveScale(id, Math.max(0.25, Number((cur - 0.05).toFixed(2))));
      } else if (ev.key === "PageUp" || ev.key === "+") {
        ev.preventDefault();
        await saveHeight(id, 1);
      } else if (ev.key === "PageDown" || ev.key === "-") {
        ev.preventDefault();
        await saveHeight(id, -1);
      } else if (ev.key === "]") {
        ev.preventDefault();
        await saveStack(id, +1);
      } else if (ev.key === "[") {
        ev.preventDefault();
        await saveStack(id, -1);
      } else if (ev.key === "Delete") {
        ev.preventDefault();
        await deleteItem(id);
      }
    }

    // Roda do mouse (com Ctrl ou Alt) para girar item selecionado
    function bindWheelRotate() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      container.addEventListener(
        "wheel",
        async (ev) => {
          // Zoom do canvas quando sem modificadores
          if (!ev.ctrlKey && !ev.altKey && !ev.shiftKey) {
            ev.preventDefault();
            const rect = container.getBoundingClientRect();
            const mx = ev.clientX - rect.left;
            const my = ev.clientY - rect.top;
            const dir = ev.deltaY < 0 ? 1 : -1; // roda pra cima = zoom in
            const next = Math.max(0.6, Math.min(2.0, SCENE.zoom + dir * 0.1));
            if (SCENE.world) {
              // ancora o zoom no cursor
              const local = SCENE.world.toLocal(new PIXI.Point(mx, my));
              SCENE.world.pivot.set(local.x, local.y);
              SCENE.world.position.set(mx, my);
              SCENE.world.scale.set(next);
              SCENE.zoom = next;
              if (SCENE.selectedId) updateOverlayPosition(SCENE.selectedId);
            }
            return;
          }
          if (!SCENE.selectedId) return;
          // Shift: escala; Ctrl/Alt: rota√ß√£o
          if (ev.shiftKey) {
            ev.preventDefault();
            const id = SCENE.selectedId;
            const entry = SCENE.items.get(id);
            const cur = Number(entry?.item?.scale || 1.0);
            const next = ev.deltaY > 0 ? cur - 0.05 : cur + 0.05;
            await saveScale(
              id,
              Math.max(0.25, Math.min(2.0, Number(next.toFixed(2))))
            );
            updateOverlayScaleDisplay(id);
            return;
          }
          if (!ev.ctrlKey && !ev.altKey) return; // somente com modificador
          ev.preventDefault();
          const id = SCENE.selectedId;
          const dir = ev.deltaY > 0 ? 15 : -15;
          await saveNudge(id, 0, 0, dir);
          updateOverlayRotationDisplay(id);
        },
        { passive: false }
      );
    }

    // Expor e inicializar
    function destroy() {
      try {
        if (BOUND.keydown) window.removeEventListener("keydown", BOUND.keydown);
        if (BOUND.keyup) window.removeEventListener("keyup", BOUND.keyup);
        if (BOUND.resize) window.removeEventListener("resize", BOUND.resize);
        if (BOUND.htmx)
          document.removeEventListener("htmx:afterSwap", BOUND.htmx);
        if (BOUND.click) {
          const container = document.getElementById("corner-canvas");
          if (container && BOUND.click.onCanvasDown)
            container.removeEventListener(
              "pointerdown",
              BOUND.click.onCanvasDown
            );
          if (BOUND.click.onDocDown)
            document.removeEventListener("pointerdown", BOUND.click.onDocDown);
        }
        if (BOUND.pan) {
          const container = document.getElementById("corner-canvas");
          if (container && BOUND.pan.onDown)
            container.removeEventListener("pointerdown", BOUND.pan.onDown);
        }
      } catch (_) {}
      try {
        const container = document.getElementById("corner-canvas");
        if (PIXI_APP) {
          PIXI_APP.destroy(true, {
            children: true,
            texture: true,
            baseTexture: true,
          });
          if (container) container.innerHTML = "";
        }
      } catch (_) {}
      PIXI_APP = null;
    }

    window.__CornerInstance = { destroy };
    // init now (scripts de p√°ginas htmx executam ap√≥s inser√ß√£o no DOM)
    ensurePixi();
    bindResize();
    bindHtmx();
    bindWheelRotate();
    bindPan();
    bindOutsideClicks();
    // carregar itens do furniture2 (manifest)
    try {
      loadInventoryFromManifest();
    } catch {}

    // Invent√°rio din√¢mico (carrega manifest furniture2 e liga intera√ß√µes)
    const search = document.getElementById("inventory-search");
    const groups = document.getElementById("inventory-groups");

    function renderInventoryGroups(data) {
      if (!groups) return;
      groups.innerHTML = "";
      const categories = Object.keys(data || {});
      categories.forEach((cat) => {
        const section = document.createElement("section");
        section.className =
          "inv-group border border-violet-700/30 rounded-lg overflow-hidden";
        section.innerHTML = `
          <button type="button" class="inv-toggle w-full flex items-center justify-between px-3 py-2 bg-white/5 hover:bg-white/10 text-left">
            <span class="font-medium text-violet-100">${cat}</span>
            <span class="inv-count text-xs text-violet-300 ml-2"></span>
            <span class="inv-chevron">‚ñæ</span>
          </button>
          <ul class="inv-items divide-y divide-violet-700/20"></ul>
        `;
        const ul = section.querySelector(".inv-items");
        (data[cat] || []).forEach((item) => {
          const li = document.createElement("li");
          li.className = "px-3 py-2 hover:bg-white/10 cursor-pointer";
          li.setAttribute("draggable", "true");
          li.setAttribute("data-key", item.key);
          li.textContent = item.label || item.key;
          ul.appendChild(li);
        });
        groups.appendChild(section);
      });
      bindInventoryInteractions();
      refreshGroupCounts();
    }

    async function loadInventoryFromManifest() {
      try {
        const res = await fetch("/public/furniture2/manifest.json", {
          cache: "no-store",
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        renderInventoryGroups(data);
      } catch (e) {
        console.warn(
          "[corner] manifest furniture2 n√£o encontrado, mantendo invent√°rio padr√£o."
        );
      }
    }

    function bindInventoryInteractions() {
      if (!groups) return;
      // toggle de grupos
      groups.querySelectorAll(".inv-group").forEach((grp) => {
        const btn = grp.querySelector(".inv-toggle");
        const ul = grp.querySelector(".inv-items");
        const chevron = grp.querySelector(".inv-chevron");
        // id est√°vel do grupo baseado no t√≠tulo
        const titleEl = btn && btn.querySelector("span.font-medium");
        const groupId =
          (titleEl &&
            (titleEl.textContent || "").toLowerCase().replace(/\s+/g, "-")) ||
          Math.random().toString(36).slice(2);
        grp.dataset.groupId = groupId;

        const storageKey = (id) => `inv_open_${id}`;
        const loadOpen = () => {
          try {
            const v = localStorage.getItem(storageKey(groupId));
            if (v === null) return true; // padr√£o: aberto
            return v === "1";
          } catch {
            return true;
          }
        };
        const saveOpen = (open) => {
          try {
            localStorage.setItem(storageKey(groupId), open ? "1" : "0");
          } catch {}
        };

        const setOpen = (open, persist = false) => {
          ul.style.display = open ? "" : "none";
          if (chevron) chevron.textContent = open ? "‚ñæ" : "‚ñ∏";
          grp.dataset.open = open ? "1" : "0";
          if (persist) saveOpen(open);
        };
        // estado inicial (persistido)
        setOpen(loadOpen());
        if (btn)
          btn.addEventListener("click", () => {
            const open = grp.dataset.open !== "0";
            setOpen(!open, true);
          });
      });
      // clique/drag/dblclick
      groups.querySelectorAll("[data-key]").forEach((li) => {
        // DRAG: iniciar arraste com dataTransfer
        li.addEventListener("dragstart", (ev) => {
          const key = li.getAttribute("data-key");
          try {
            ev.dataTransfer.setData("application/x-corner-item", key);
            ev.dataTransfer.setData("text/plain", key);
            ev.dataTransfer.effectAllowed = "copy";
          } catch {}
          DRAG_STATE.key = key;
        });
        li.addEventListener("dragend", () => {
          DRAG_STATE.key = null;
          hideGhost();
        });
        li.addEventListener("click", () => {
          const key = li.getAttribute("data-key");
          const sel = document.querySelector(
            '#add-item-form select[name="item_key"]'
          );
          if (sel) {
            sel.value = key;
            sel.dispatchEvent(new Event("change", { bubbles: true }));
          }
          // destaque visual no invent√°rio
          groups.querySelectorAll("[data-key]").forEach((el) => {
            el.classList.toggle(
              "bg-white/10",
              el.getAttribute("data-key") === key
            );
          });
          // garantir grupo aberto
          const grp = li.closest(".inv-group");
          if (grp) {
            grp.style.display = "";
            const chevron = grp.querySelector(".inv-chevron");
            const ul = grp.querySelector(".inv-items");
            if (ul) ul.style.display = "";
            if (chevron) chevron.textContent = "‚ñæ";
            grp.dataset.open = "1";
            try {
              const gid = grp.dataset.groupId;
              if (gid) localStorage.setItem(`inv_open_${gid}`, "1");
            } catch {}
          }
        });
        // duplo clique: cria item no centro do canvas
        li.addEventListener("dblclick", async () => {
          const key = li.getAttribute("data-key");
          const container = document.getElementById("corner-canvas");
          if (!container) return;
          const rect = container.getBoundingClientRect();
          const px = rect.width / 2;
          const py = rect.height / 2;
          const local = SCENE.world
            ? SCENE.world.toLocal(new PIXI.Point(px, py))
            : new PIXI.Point(px, py);
          let best = { d: Infinity, gx: 0, gy: 0 };
          for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
            for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
              const { sx, sy } = HS_ISO.projectWorld(i, j);
              const dx = sx - local.x,
                dy = sy - local.y;
              const d = dx * dx + dy * dy;
              if (d < best.d) best = { d, gx: i, gy: j };
            }
          }
          // permitir posicionar nas bordas do canvas
          const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
          const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
          const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
          const xPct = gridToPct(gx);
          const yPct = gridToPct(gy);
          const CSRF =
            (document.querySelector('meta[name="csrf-token"]') || {}).content ||
            "";
          try {
            const res = await fetch("/corner/items", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRF-Token": CSRF,
                "HX-Request": "true",
              },
              body: JSON.stringify({ item_key: key, x: xPct, y: yPct }),
            });
            if (!res.ok) return;
            const html = await res.text();
            const node = htmlToNode(html);
            const data = domItemToData(node);
            data.x = xPct;
            data.y = yPct;
            try {
              window.__cornerItems = Array.isArray(window.__cornerItems)
                ? window.__cornerItems
                : [];
              window.__cornerItems.push(data);
            } catch {}
            addOrUpdateItem(data);
            selectItem(data.id);
            refreshGroupCounts();
          } catch (e) {
            console.error(e);
          }
        });
      });
    }
    if (search && groups) {
      const onInput = () => {
        const q = (search.value || "").trim().toLowerCase();
        groups.querySelectorAll(".inv-group").forEach((grp) => {
          const items = Array.from(grp.querySelectorAll("[data-key]"));
          let any = false;
          items.forEach((li) => {
            const txt = (li.textContent || "").toLowerCase();
            const show = !q || txt.includes(q);
            li.style.display = show ? "" : "none";
            if (show) any = true;
          });
          // esconde grupo sem matches
          grp.style.display = any ? "" : "none";
          // com busca ativa, abre grupos com resultados; sem busca, restaura estado salvo
          const btn = grp.querySelector(".inv-toggle");
          const ul = grp.querySelector(".inv-items");
          const chevron = grp.querySelector(".inv-chevron");
          const groupId = grp.dataset.groupId;
          const storageKey = (id) => `inv_open_${id}`;
          const setOpen = (open) => {
            ul.style.display = open ? "" : "none";
            if (chevron) chevron.textContent = open ? "‚ñæ" : "‚ñ∏";
            grp.dataset.open = open ? "1" : "0";
          };
          if (q) {
            setOpen(any); // abrir quando h√° resultado
          } else {
            try {
              const v = localStorage.getItem(storageKey(groupId));
              setOpen(v === null ? true : v === "1");
            } catch {
              setOpen(true);
            }
          }
        });
      };
      search.addEventListener("input", onInput);
    }

    // Atualiza contadores por grupo (quantidade de itens no canvas por categoria)
    function refreshGroupCounts() {
      if (!groups) return;
      const all = Array.isArray(window.__cornerItems)
        ? window.__cornerItems
        : [];
      groups.querySelectorAll(".inv-group").forEach((grp) => {
        const cnt = grp.querySelector(".inv-count");
        if (!cnt) return;
        const keys = Array.from(grp.querySelectorAll("[data-key]")).map((n) =>
          n.getAttribute("data-key")
        );
        let total = 0;
        all.forEach((it) => {
          if (keys.includes(String(it.item_key))) total += 1;
        });
        cnt.textContent = total > 0 ? `(${total})` : "";
      });
    }
    refreshGroupCounts();

    // Ouvir eventos de inser√ß√£o/remo√ß√£o para atualizar contadores
    document.addEventListener("htmx:afterSwap", (e) => {
      const target = e && e.detail && e.detail.target;
      if (target && target.id === "corner-outbox") {
        // addOrUpdateItem j√° atualiza __cornerItems; s√≥ atualizar contadores
        setTimeout(refreshGroupCounts, 0);
      }
    });
    document.addEventListener("itemRemoved", () =>
      setTimeout(refreshGroupCounts, 0)
    );

    // Drag & Drop no canvas: permitir soltar para criar item na posi√ß√£o
    (function enableCanvasDrop() {
      const container = document.getElementById("corner-canvas");
      if (!container) return;
      container.addEventListener("dragover", (ev) => {
        // aceita c√≥pia
        try {
          ev.dataTransfer.dropEffect = "copy";
          const rect = container.getBoundingClientRect();
          let key = "";
          try {
            key =
              DRAG_STATE.key ||
              ev.dataTransfer.getData("application/x-corner-item") ||
              ev.dataTransfer.getData("text/plain") ||
              "";
          } catch {}
          if (key) {
            ensureGhost(key);
            updateGhostPosition(ev.clientX - rect.left, ev.clientY - rect.top);
          }
        } catch {}
        container.addEventListener("dragenter", (ev) => {
          const rect = container.getBoundingClientRect();
          let key = "";
          try {
            key =
              DRAG_STATE.key ||
              ev.dataTransfer.getData("application/x-corner-item") ||
              ev.dataTransfer.getData("text/plain") ||
              "";
          } catch {}
          if (key) {
            ensureGhost(key);
            updateGhostPosition(ev.clientX - rect.left, ev.clientY - rect.top);
          }
        });
        container.addEventListener("dragleave", (ev) => {
          // se saiu do canvas, esconder ghost
          const to = ev.relatedTarget;
          const leftCanvas = !(
            to &&
            (to === container || (to.closest && to.closest("#corner-canvas")))
          );
          if (leftCanvas) hideGhost();
        });
        ev.preventDefault();
      });
      container.addEventListener("drop", async (ev) => {
        ev.preventDefault();
        let key = "";
        try {
          key =
            ev.dataTransfer.getData("application/x-corner-item") ||
            ev.dataTransfer.getData("text/plain") ||
            "";
        } catch {}
        if (!key) return;
        // calcular posi√ß√£o em grid a partir do ponto solto
        const rect = container.getBoundingClientRect();
        const px = ev.clientX - rect.left;
        const py = ev.clientY - rect.top;
        // converter para coordenadas do mundo (compensa zoom/pan)
        const local = SCENE.world
          ? SCENE.world.toLocal(new PIXI.Point(px, py))
          : new PIXI.Point(px, py);
        // buscar o ponto de grade mais pr√≥ximo (com resolu√ß√£o 0.25)
        let best = { d: Infinity, gx: 0, gy: 0 };
        for (let i = 0; i < HS_ISO.gridN; i += 0.25) {
          for (let j = 0; j < HS_ISO.gridN; j += 0.25) {
            const { sx, sy } = HS_ISO.projectWorld(i, j);
            const dx = sx - local.x,
              dy = sy - local.y;
            const d = dx * dx + dy * dy;
            if (d < best.d) best = { d, gx: i, gy: j };
          }
        }
        // permitir posicionar nas bordas do canvas
        const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
        const gx = clamp(best.gx, 0, HS_ISO.gridN - 1);
        const gy = clamp(best.gy, 0, HS_ISO.gridN - 1);
        const xPct = gridToPct(gx);
        const yPct = gridToPct(gy);
        // criar item via POST /corner/items (hx-like)
        const CSRF =
          (document.querySelector('meta[name="csrf-token"]') || {}).content ||
          "";
        try {
          const res = await fetch("/corner/items", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": CSRF,
              "HX-Request": "true",
            },
            body: JSON.stringify({ item_key: key, x: xPct, y: yPct }),
          });
          if (!res.ok) return;
          const html = await res.text();
          const node = htmlToNode(html);
          const data = domItemToData(node);
          // manter x,y que acabamos de definir (o parcial j√° deve conter), mas garantimos
          data.x = xPct;
          data.y = yPct;
          // atualizar internamente
          try {
            window.__cornerItems = Array.isArray(window.__cornerItems)
              ? window.__cornerItems
              : [];
            window.__cornerItems.push(data);
          } catch {}
          addOrUpdateItem(data);
          selectItem(data.id);
          refreshGroupCounts();
        } catch (e) {
          console.error(e);
        }
        hideGhost();
      });
    })();
  })();
</script>
