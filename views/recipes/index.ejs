<style>
  /* Custom scrollbar para modais */
  .scrollbar-thin::-webkit-scrollbar {
    width: 8px;
  }
  
  .scrollbar-thin::-webkit-scrollbar-track {
    background: rgba(76, 29, 149, 0.2);
    border-radius: 4px;
  }
  
  .scrollbar-thin::-webkit-scrollbar-thumb {
    background: rgb(124, 58, 237);
    border-radius: 4px;
  }
  
  .scrollbar-thin::-webkit-scrollbar-thumb:hover {
    background: rgb(139, 92, 246);
  }

  @keyframes slideIn {
    from {
      transform: translateY(-20px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .recipe-card {
    animation: slideIn 0.3s ease-out;
  }

  /* Image editor styles */
  .image-editor-container {
    position: relative;
    width: 100%;
    max-width: 500px;
    height: 300px;
    overflow: hidden;
    background: #1a0b2e;
    border-radius: 8px;
    cursor: grab;
    touch-action: none;
    margin: 0 auto;
    user-select: none;
  }

  .image-editor-container:active {
    cursor: grabbing;
  }

  .image-editor-container img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    user-select: none;
    -webkit-user-drag: none;
    pointer-events: none;
    will-change: object-position;
  }


</style>

<div class="container mx-auto px-2 sm:px-4 py-4 sm:py-8 max-w-7xl">
  <div class="glass rounded-xl sm:rounded-2xl border border-violet-700/30 bg-white/5 p-4 sm:p-6 md:p-8">
    <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-6 sm:mb-8">
      <h1 class="page-title text-2xl sm:text-3xl font-bold bg-gradient-to-r from-violet-400 to-fuchsia-400 bg-clip-text text-transparent">
        üç≥ Nossas Receitas
      </h1>
      <button 
        id="add-recipe-btn"
        class="w-full sm:w-auto px-4 sm:px-6 py-2.5 bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-700 hover:to-fuchsia-700 text-white rounded-lg font-medium transition-all shadow-lg hover:shadow-violet-500/50 hover:scale-105 text-sm sm:text-base"
      >
        <svg class="inline-block w-4 h-4 sm:w-5 sm:h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
        </svg>
        Nova Receita
      </button>
    </div>

    <% if (recipes.length === 0) { %>
      <div class="text-center py-12 sm:py-16">
        <div class="text-6xl sm:text-8xl mb-4">üë®‚Äçüç≥</div>
        <h3 class="text-xl sm:text-2xl font-bold text-violet-200 mb-2">Nenhuma receita ainda</h3>
        <p class="text-sm sm:text-base text-violet-400 mb-6">Comece adicionando suas receitas favoritas!</p>
        <button 
          class="add-recipe-trigger px-6 py-2.5 bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-700 hover:to-fuchsia-700 text-white rounded-lg font-medium transition-all shadow-lg text-sm sm:text-base"
        >
          Adicionar primeira receita
        </button>
      </div>
    <% } else { %>
      <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6">
        <% recipes.forEach(recipe => { %>
          <%- include('_recipe_card', { recipe }) %>
        <% }) %>
      </div>
    <% } %>
  </div>
</div>

<%- include('_add_recipe_modal') %>
<%- include('_edit_recipe_modal') %>
<%- include('_recipe_detail_modal') %>

<script>
(function() {
  // Modais
  const addModal = document.getElementById('add-recipe-modal');
  const editModal = document.getElementById('edit-recipe-modal');
  const detailModal = document.getElementById('recipe-detail-modal');

  // Abrir modal de adicionar
  document.querySelectorAll('#add-recipe-btn, .add-recipe-trigger').forEach(btn => {
    btn.addEventListener('click', () => {
      openAddRecipeModal();
    });
  });

  function openAddRecipeModal() {
    document.getElementById('add-recipe-form').reset();
    document.getElementById('photo-preview').classList.add('hidden');
    addModal.classList.remove('hidden');
    setTimeout(() => {
      addModal.style.opacity = '1';
      document.getElementById('add-recipe-content').style.transform = 'scale(1)';
    }, 10);
  }

  function closeAddRecipeModal() {
    addModal.style.opacity = '0';
    document.getElementById('add-recipe-content').style.transform = 'scale(0.9)';
    setTimeout(() => addModal.classList.add('hidden'), 300);
  }

  document.getElementById('close-add-recipe-btn')?.addEventListener('click', closeAddRecipeModal);
  document.getElementById('cancel-add-recipe-btn')?.addEventListener('click', closeAddRecipeModal);
  addModal?.addEventListener('click', (e) => {
    if (e.target === addModal) closeAddRecipeModal();
  });

  // Preview de foto ao adicionar
  document.getElementById('recipe-photo')?.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const preview = document.getElementById('photo-preview');
        preview.querySelector('img').src = e.target.result;
        preview.classList.remove('hidden');
      };
      reader.readAsDataURL(file);
    }
  });

  // Submeter nova receita
  document.getElementById('add-recipe-form')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
    
    try {
      const response = await fetch('/recipes', {
        method: 'POST',
        headers: {
          'X-CSRF-Token': csrfToken
        },
        body: formData
      });

      const data = await response.json();

      if (data.success) {
        window.showToast('Receita adicionada com sucesso!');
        closeAddRecipeModal();
        setTimeout(() => location.reload(), 500);
      } else {
        throw new Error(data.error || 'Erro ao adicionar receita');
      }
    } catch (error) {
      console.error('Erro:', error);
      window.showToast(error.message || 'Erro ao adicionar receita', 'error');
    }
  });

  // Delega√ß√£o de eventos para cards
  document.addEventListener('click', async (e) => {
    // Abrir detalhes
    const detailBtn = e.target.closest('.view-recipe-btn');
    if (detailBtn) {
      const recipeId = detailBtn.dataset.recipeId;
      openRecipeDetail(recipeId);
      return;
    }

    // Avaliar receita
    const ratingBtn = e.target.closest('.rating-btn');
    if (ratingBtn) {
      const rating = parseInt(ratingBtn.dataset.rating);
      const recipeId = ratingBtn.dataset.recipeId;
      await rateRecipe(recipeId, rating);
      return;
    }

    // Deletar receita
    const deleteBtn = e.target.closest('.delete-recipe-btn');
    if (deleteBtn) {
      if (confirm('Tem certeza que deseja deletar esta receita?')) {
        const recipeId = deleteBtn.dataset.recipeId;
        await deleteRecipe(recipeId);
      }
      return;
    }
  });

  async function rateRecipe(recipeId, rating) {
    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      
      const response = await fetch(`/recipes/${recipeId}/rating`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify({ rating })
      });

      const data = await response.json();

      if (data.success) {
        window.showToast(`Avalia√ß√£o de ${rating} üòã salva!`);
        
        // Atualizar UI sem reload
        updateRecipeRatingUI(recipeId, rating);
      } else {
        throw new Error(data.error || 'Erro ao avaliar');
      }
    } catch (error) {
      console.error('Erro:', error);
      window.showToast(error.message || 'Erro ao avaliar receita', 'error');
    }
  }

  // Atualizar UI da avalia√ß√£o sem reload
  function updateRecipeRatingUI(recipeId, rating) {
    // Atualizar no card
    const card = document.querySelector(`[data-recipe-id="${recipeId}"]`);
    if (card) {
      const ratingBtns = card.querySelectorAll('.rating-btn');
      ratingBtns.forEach((btn, index) => {
        const star = btn.querySelector('span');
        if (star) {
          star.className = (index + 1) <= rating ? 'text-lg sm:text-xl opacity-100' : 'text-lg sm:text-xl opacity-30';
        }
      });
      
      // Atualizar texto de "Clique para avaliar" -> "Clique para alterar"
      const helpText = card.querySelector('.rating-btn + .text-\\[10px\\]');
      if (helpText) {
        helpText.textContent = 'Clique para alterar';
      }
    }
    
    // Atualizar no modal de detalhes se estiver aberto
    const modal = document.getElementById('recipe-detail-modal');
    if (modal && !modal.classList.contains('hidden')) {
      const modalRatingBtns = modal.querySelectorAll('.rating-btn');
      modalRatingBtns.forEach((btn, index) => {
        const btnRecipeId = btn.getAttribute('data-recipe-id');
        if (btnRecipeId == recipeId) {
          const star = btn.querySelector('span');
          if (star) {
            star.className = (index + 1) <= rating ? 'text-xl sm:text-2xl opacity-100' : 'text-xl sm:text-2xl opacity-30';
          }
        }
      });
    }
  }

  async function deleteRecipe(recipeId) {
    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      
      const response = await fetch(`/recipes/${recipeId}`, {
        method: 'DELETE',
        headers: {
          'X-CSRF-Token': csrfToken
        }
      });

      const data = await response.json();

      if (data.success) {
        window.showToast('Receita deletada com sucesso!');
        setTimeout(() => location.reload(), 500);
      } else {
        throw new Error(data.error || 'Erro ao deletar');
      }
    } catch (error) {
      console.error('Erro:', error);
      window.showToast(error.message || 'Erro ao deletar receita', 'error');
    }
  }

  function openRecipeDetail(recipeId) {
    const recipes = <%- JSON.stringify(recipes) %>;
    const recipe = recipes.find(r => r.id == recipeId);
    
    if (!recipe) return;

    // Salvar dados do crop no estado global para usar no editor
    window.currentRecipeCropData = {
      crop_x: recipe.crop_x || 50,
      crop_y: recipe.crop_y || 50
    };

    const modal = document.getElementById('recipe-detail-modal');
    const content = document.getElementById('recipe-detail-content');

    // Preencher conte√∫do
    content.innerHTML = `
      <div class="space-y-4 sm:space-y-6">
        <!-- Foto clic√°vel para editar -->
        <div class="relative">
          <div id="photo-display-${recipe.id}" class="relative group cursor-pointer photo-edit-trigger" data-recipe-id="${recipe.id}">
            ${recipe.photo_path ? `
              <img id="detail-photo-${recipe.id}" src="${recipe.photo_path}" alt="${recipe.title}" class="w-full h-48 sm:h-64 object-cover rounded-lg">
            ` : `
              <div id="detail-photo-${recipe.id}" class="w-full h-48 sm:h-64 bg-violet-900/20 rounded-lg flex items-center justify-center">
                <svg class="w-16 h-16 sm:w-24 sm:h-24 text-violet-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
              </div>
            `}
            <div class="absolute inset-0 bg-black/50 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
              <div class="text-white text-center">
                <svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
                <span class="text-sm font-medium">Clique para editar foto</span>
              </div>
            </div>
          </div>
          
          <!-- Editor de Imagem (oculto inicialmente) -->
          <div id="photo-editor-${recipe.id}" class="hidden">
            <div class="text-center text-sm text-violet-300 mb-2 flex items-center justify-center gap-2">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
              </svg>
              <span>Arraste a imagem para posicionar</span>
            </div>
            <div class="image-editor-container" id="editor-container-${recipe.id}">
              <img id="editor-image-${recipe.id}" src="" alt="Editor">
            </div>
            <div class="flex gap-2 mt-3">
              <button class="cancel-edit-btn flex-1 px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white text-sm rounded-lg transition" data-recipe-id="${recipe.id}">
                Cancelar
              </button>
              <button class="save-edit-btn flex-1 px-4 py-2 bg-violet-600 hover:bg-violet-700 text-white text-sm rounded-lg transition" data-recipe-id="${recipe.id}">
                Salvar Posi√ß√£o
              </button>
            </div>
          </div>
          <input type="file" id="edit-photo-input-${recipe.id}" class="hidden" accept="image/jpeg,image/jpg,image/png,image/webp" data-recipe-id="${recipe.id}">
        </div>

        <div>
          <!-- T√≠tulo edit√°vel -->
          <input 
            type="text" 
            id="detail-title-${recipe.id}"
            value="${recipe.title}"
            class="w-full text-xl sm:text-2xl font-bold text-violet-100 mb-2 bg-violet-900/20 border border-violet-700/30 rounded-lg px-3 py-2 focus:outline-none focus:border-fuchsia-500 title-edit-input"
            data-recipe-id="${recipe.id}"
          />
          ${recipe.reference_link ? `
            <a href="${recipe.reference_link}" target="_blank" rel="noopener noreferrer" class="text-sm text-fuchsia-400 hover:text-fuchsia-300 inline-flex items-center gap-1">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
              </svg>
              Ver receita original
            </a>
          ` : ''}
        </div>

        <!-- Avalia√ß√µes e Coment√°rios -->
        <div class="space-y-4">
          <!-- Sua avalia√ß√£o -->
          <div class="glass rounded-lg p-4 border border-violet-700/30">
            <div class="flex justify-between items-start mb-3">
              <span class="text-sm font-medium text-violet-300">Sua avalia√ß√£o</span>
              <div class="flex gap-1">
                ${[1,2,3,4,5].map(i => `
                  <button class="rating-btn p-1 transition-transform hover:scale-110" data-rating="${i}" data-recipe-id="${recipe.id}">
                    <span class="text-xl sm:text-2xl ${recipe.currentUserRating >= i ? 'opacity-100' : 'opacity-30'}">${'üòã'}</span>
                  </button>
                `).join('')}
              </div>
            </div>
            <textarea 
              id="current-user-comment"
              class="w-full bg-violet-900/20 border border-violet-700/30 rounded-lg px-3 py-2 text-sm text-violet-100 placeholder-violet-500 focus:outline-none focus:border-fuchsia-500 resize-none"
              rows="3"
              placeholder="Escreva seu coment√°rio..."
            >${recipe.currentUserComment || ''}</textarea>
            <button 
              class="save-comment-btn mt-2 px-4 py-1.5 bg-violet-600 hover:bg-violet-700 text-white text-sm rounded-lg transition"
              data-recipe-id="${recipe.id}"
            >
              Salvar coment√°rio
            </button>
          </div>

          <!-- Avalia√ß√£o do parceiro -->
          <div class="glass rounded-lg p-4 border border-violet-700/30">
            <div class="flex justify-between items-start mb-3">
              <span class="text-sm font-medium text-violet-300">Avalia√ß√£o do parceiro</span>
              <div class="flex gap-1">
                ${[1,2,3,4,5].map(i => `
                  <span class="text-xl sm:text-2xl ${recipe.partnerRating >= i ? 'opacity-100' : 'opacity-30'}">${'üòã'}</span>
                `).join('')}
              </div>
            </div>
            ${recipe.partnerComment ? `
              <p class="text-sm text-violet-200 italic">"${recipe.partnerComment}"</p>
            ` : `
              <p class="text-sm text-violet-500 italic">Ainda n√£o comentou</p>
            `}
          </div>

          ${recipe.hasCurrentUserRated && recipe.hasPartnerRated ? `
            <div class="text-center pt-2 border-t border-violet-700/30">
              <span class="text-sm text-violet-300">Avalia√ß√£o m√©dia: </span>
              <span class="text-2xl font-bold text-yellow-400">
                ${((recipe.currentUserRating + recipe.partnerRating) / 2).toFixed(1)}
              </span>
              <span class="text-lg">üòã</span>
            </div>
          ` : ''}
        </div>
      </div>
    `;

    modal.classList.remove('hidden');
    setTimeout(() => {
      modal.style.opacity = '1';
      document.querySelector('#recipe-detail-modal .glass').style.transform = 'scale(1)';
    }, 10);

    // Configurar event listeners ap√≥s carregar o conte√∫do
    setTimeout(() => {
      // Listener para clicar na foto (abre editor se foto existe, ou file picker se n√£o existe)
      const photoTrigger = document.querySelector('.photo-edit-trigger');
      if (photoTrigger) {
        photoTrigger.addEventListener('click', () => {
          const recipeId = photoTrigger.dataset.recipeId;
          const hasPhoto = recipe.photo_path;
          
          if (hasPhoto) {
            // Se tem foto, abre o editor
            openPhotoEditor(recipeId, recipe.photo_path);
          } else {
            // Se n√£o tem foto, abre file picker
            document.getElementById(`edit-photo-input-${recipeId}`).click();
          }
        });
      }

      // Listener para mudan√ßa de foto (upload nova)
      const photoInput = document.querySelector(`#edit-photo-input-${recipeId}`);
      if (photoInput) {
        photoInput.addEventListener('change', (e) => {
          const recipeId = e.target.dataset.recipeId;
          const file = e.target.files[0];
          if (file) {
            // Ao selecionar nova foto, abre o editor
            const reader = new FileReader();
            reader.onload = (event) => {
              openPhotoEditor(recipeId, event.target.result, file);
            };
            reader.readAsDataURL(file);
          }
        });
      }

      // Listener para t√≠tulo (blur = quando sai do campo)
      const titleInput = document.querySelector('.title-edit-input');
      if (titleInput) {
        titleInput.addEventListener('blur', (e) => {
          const recipeId = e.target.dataset.recipeId;
          const title = e.target.value;
          updateRecipeTitle(recipeId, title);
        });
      }

      // Listener para bot√£o de salvar coment√°rio
      const saveCommentBtn = document.querySelector('.save-comment-btn');
      if (saveCommentBtn) {
        saveCommentBtn.addEventListener('click', () => {
          const recipeId = saveCommentBtn.dataset.recipeId;
          const comment = document.getElementById('current-user-comment').value;
          saveComment(recipeId, comment);
        });
      }

      // Listeners para bot√µes do editor de imagem
      const cancelBtn = document.querySelector('.cancel-edit-btn');
      const saveEditBtn = document.querySelector('.save-edit-btn');

      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          closePhotoEditor(recipeId);
        });
      }

      if (saveEditBtn) {
        saveEditBtn.addEventListener('click', () => {
          savePhotoEdit(recipeId);
        });
      }
    }, 50);
  }

  function closeRecipeDetail() {
    const modal = document.getElementById('recipe-detail-modal');
    modal.style.opacity = '0';
    document.querySelector('#recipe-detail-modal .glass').style.transform = 'scale(0.9)';
    setTimeout(() => modal.classList.add('hidden'), 300);
  }

  document.getElementById('close-recipe-detail-btn')?.addEventListener('click', closeRecipeDetail);
  detailModal?.addEventListener('click', (e) => {
    if (e.target === detailModal) closeRecipeDetail();
  });

  window.saveComment = async function(recipeId, comment) {
    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      
      const response = await fetch(`/recipes/${recipeId}/comment`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify({ comment })
      });

      const data = await response.json();

      if (data.success) {
        window.showToast('Coment√°rio salvo!');
        // N√£o precisa atualizar UI, o textarea j√° tem o valor
      } else {
        throw new Error(data.error || 'Erro ao salvar coment√°rio');
      }
    } catch (error) {
      console.error('Erro:', error);
      window.showToast(error.message || 'Erro ao salvar coment√°rio', 'error');
    }
  };

  // Atualizar t√≠tulo da receita
  window.updateRecipeTitle = async function(recipeId, title) {
    if (!title || !title.trim()) {
      window.showToast('T√≠tulo n√£o pode estar vazio', 'error');
      return;
    }

    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      const formData = new FormData();
      formData.append('title', title.trim());

      const response = await fetch(`/recipes/${recipeId}`, {
        method: 'PUT',
        headers: {
          'X-CSRF-Token': csrfToken
        },
        body: formData
      });

      const data = await response.json();

      if (data.success) {
        window.showToast('T√≠tulo atualizado!');
        
        // Atualizar t√≠tulo no card
        const card = document.querySelector(`[data-recipe-id="${recipeId}"]`);
        if (card) {
          const cardTitle = card.querySelector('h3');
          if (cardTitle) {
            cardTitle.textContent = title.trim();
            cardTitle.setAttribute('title', title.trim());
          }
        }
      } else {
        throw new Error(data.error || 'Erro ao atualizar t√≠tulo');
      }
    } catch (error) {
      console.error('Erro:', error);
      window.showToast(error.message || 'Erro ao atualizar t√≠tulo', 'error');
    }
  };

  // Estado do editor de imagem
  let imageEditorState = {
    isDragging: false,
    startX: 0,
    startY: 0,
    posX: 50,  // Posi√ß√£o em % (0-100)
    posY: 50,  // Posi√ß√£o em % (0-100)
    originalFile: null,
    // Guardar handlers para poder remover depois
    handlers: null,
    currentRecipeId: null,
    // RAF para otimiza√ß√£o
    rafId: null,
    pendingUpdate: false
  };

  // Abrir editor de foto
  function openPhotoEditor(recipeId, imageSrc, file = null) {
    const display = document.getElementById(`photo-display-${recipeId}`);
    const editor = document.getElementById(`photo-editor-${recipeId}`);
    const editorImage = document.getElementById(`editor-image-${recipeId}`);
    const container = document.getElementById(`editor-container-${recipeId}`);

    // Salvar arquivo original se for upload novo
    if (file) {
      imageEditorState.originalFile = file;
    }

    // Se a imagem √© cropada (_cropped), tentar carregar a original (_original)
    let imageToLoad = imageSrc;
    if (imageSrc.includes('_cropped')) {
      const originalSrc = imageSrc.replace('_cropped', '_original');
      imageToLoad = originalSrc;
    }

    // Carregar imagem no editor
    editorImage.src = imageToLoad;
    
    // Aguardar carregamento da imagem
    editorImage.onload = () => {
      // Mostrar editor, ocultar display
      display.classList.add('hidden');
      editor.classList.remove('hidden');
      
      // Carregar posi√ß√£o salva do crop (valores j√° em %)
      const cropData = window.currentRecipeCropData || { crop_x: 50, crop_y: 50 };
      imageEditorState.posX = cropData.crop_x || 50;
      imageEditorState.posY = cropData.crop_y || 50;
      
      // Aplicar posi√ß√£o inicial
      updateImagePosition(recipeId);
      setupImageDragging(recipeId, container, editorImage);
    };
    
    // Fallback caso a original n√£o exista
    editorImage.onerror = () => {
      if (imageToLoad !== imageSrc) {
        console.warn('Imagem original n√£o encontrada, usando atual');
        editorImage.src = imageSrc;
      }
    };
  }

  // Configurar arrastar imagem
  function setupImageDragging(recipeId, container, image) {
    // Remover listeners antigos se existirem
    if (imageEditorState.handlers) {
      document.removeEventListener('mousemove', imageEditorState.handlers.handleMouseMove);
      document.removeEventListener('mouseup', imageEditorState.handlers.handleMouseUp);
      document.removeEventListener('touchmove', imageEditorState.handlers.handleTouchMove);
      document.removeEventListener('touchend', imageEditorState.handlers.handleTouchEnd);
      container.removeEventListener('mousedown', imageEditorState.handlers.handleMouseDown);
      container.removeEventListener('touchstart', imageEditorState.handlers.handleTouchStart);
      
      // Cancelar RAF pendente
      if (imageEditorState.rafId) {
        cancelAnimationFrame(imageEditorState.rafId);
        imageEditorState.rafId = null;
      }
    }

    imageEditorState.currentRecipeId = recipeId;
    
    // Cache de dimens√µes do container (evita reflow a cada frame)
    let containerWidth = container.offsetWidth;
    let containerHeight = container.offsetHeight;

    const handleStart = (clientX, clientY) => {
      imageEditorState.isDragging = true;
      imageEditorState.startX = clientX;
      imageEditorState.startY = clientY;
      image.style.cursor = 'grabbing';
      
      // Atualizar cache de dimens√µes ao iniciar arrasto
      containerWidth = container.offsetWidth;
      containerHeight = container.offsetHeight;
    };

    const handleMove = (clientX, clientY) => {
      if (!imageEditorState.isDragging) return;
      
      // Calcular movimento em pixels desde o √∫ltimo ponto
      const deltaX = clientX - imageEditorState.startX;
      const deltaY = clientY - imageEditorState.startY;
      
      // Calcular quanto % representam os pixels de movimento (usa cache)
      const deltaXPercent = (deltaX / containerWidth) * 100;
      const deltaYPercent = (deltaY / containerHeight) * 100;
      
      // Atualizar posi√ß√£o
      imageEditorState.posX = Math.max(0, Math.min(100, imageEditorState.posX + deltaXPercent));
      imageEditorState.posY = Math.max(0, Math.min(100, imageEditorState.posY + deltaYPercent));
      
      // Atualizar posi√ß√£o inicial para o pr√≥ximo frame
      imageEditorState.startX = clientX;
      imageEditorState.startY = clientY;
      
      // Agendar atualiza√ß√£o visual apenas se n√£o h√° uma pendente
      if (!imageEditorState.pendingUpdate) {
        imageEditorState.pendingUpdate = true;
        imageEditorState.rafId = requestAnimationFrame(() => {
          updateImagePosition(recipeId);
          imageEditorState.pendingUpdate = false;
        });
      }
    };

    const handleEnd = () => {
      imageEditorState.isDragging = false;
      image.style.cursor = 'grab';
      
      // For√ßar atualiza√ß√£o final se houver RAF pendente
      if (imageEditorState.rafId) {
        cancelAnimationFrame(imageEditorState.rafId);
        updateImagePosition(recipeId);
        imageEditorState.rafId = null;
        imageEditorState.pendingUpdate = false;
      }
    };

    // Criar handlers que ser√£o guardados para remo√ß√£o posterior
    const handleMouseDown = (e) => {
      e.preventDefault();
      handleStart(e.clientX, e.clientY);
    };

    const handleMouseMove = (e) => {
      if (imageEditorState.isDragging) {
        e.preventDefault();
        handleMove(e.clientX, e.clientY);
      }
    };

    const handleMouseUp = () => {
      handleEnd();
    };

    const handleTouchStart = (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      handleStart(touch.clientX, touch.clientY);
    };

    const handleTouchMove = (e) => {
      if (imageEditorState.isDragging) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
      }
    };

    const handleTouchEnd = () => {
      handleEnd();
    };

    // Guardar handlers para remo√ß√£o posterior
    imageEditorState.handlers = {
      handleMouseDown,
      handleMouseMove,
      handleMouseUp,
      handleTouchStart,
      handleTouchMove,
      handleTouchEnd
    };

    // Mouse events
    container.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // Touch events
    container.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd);
  }

  // Atualizar posi√ß√£o da imagem
  function updateImagePosition(recipeId) {
    const image = document.getElementById(`editor-image-${recipeId}`);
    image.style.objectPosition = `${imageEditorState.posX}% ${imageEditorState.posY}%`;
    image.style.cursor = imageEditorState.isDragging ? 'grabbing' : 'grab';
  }

  // Fechar editor
  function closePhotoEditor(recipeId) {
    const display = document.getElementById(`photo-display-${recipeId}`);
    const editor = document.getElementById(`photo-editor-${recipeId}`);
    const container = document.getElementById(`editor-container-${recipeId}`);
    
    // Cancelar RAF pendente
    if (imageEditorState.rafId) {
      cancelAnimationFrame(imageEditorState.rafId);
      imageEditorState.rafId = null;
    }
    
    // Remover event listeners
    if (imageEditorState.handlers) {
      document.removeEventListener('mousemove', imageEditorState.handlers.handleMouseMove);
      document.removeEventListener('mouseup', imageEditorState.handlers.handleMouseUp);
      document.removeEventListener('touchmove', imageEditorState.handlers.handleTouchMove);
      document.removeEventListener('touchend', imageEditorState.handlers.handleTouchEnd);
      
      if (container) {
        container.removeEventListener('mousedown', imageEditorState.handlers.handleMouseDown);
        container.removeEventListener('touchstart', imageEditorState.handlers.handleTouchStart);
      }
      
      imageEditorState.handlers = null;
    }
    
    display.classList.remove('hidden');
    editor.classList.add('hidden');
    
    imageEditorState.originalFile = null;
    imageEditorState.isDragging = false;
    imageEditorState.currentRecipeId = null;
    imageEditorState.pendingUpdate = false;
  }

  // Salvar edi√ß√£o (salvar posi√ß√£o como porcentagem)
  async function savePhotoEdit(recipeId) {
    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      
      // Mostrar loading
      window.showToast('Processando imagem...', 'info');
      
      // Enviar posi√ß√µes em porcentagem (0-100) - servidor ir√° processar com Sharp!
      const response = await fetch(`/recipes/${recipeId}/crop`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify({
          crop_x: imageEditorState.posX,
          crop_y: imageEditorState.posY
        })
      });

      const data = await response.json();

      if (data.success) {
        window.showToast('Imagem atualizada!');
        
        // Fechar editor
        closePhotoEditor(recipeId);
        
        // Atualizar imagem no card E no modal sem reload!
        if (data.photo_path) {
          updateRecipePhotoUI(recipeId, data.photo_path);
        }
      } else {
        throw new Error(data.error || 'Erro ao salvar enquadramento');
      }
    } catch (error) {
      console.error('Erro ao salvar edi√ß√£o:', error);
      window.showToast(error.message || 'Erro ao salvar enquadramento', 'error');
    }
  }

  // Atualizar UI da foto sem reload
  function updateRecipePhotoUI(recipeId, newPhotoPath) {
    // Adicionar timestamp para for√ßar reload da imagem (cache bust)
    const photoUrlWithCache = newPhotoPath + '?t=' + Date.now();
    
    // Atualizar no card
    const card = document.querySelector(`[data-recipe-id="${recipeId}"]`);
    if (card) {
      const cardImg = card.querySelector('img[alt]');
      if (cardImg) {
        cardImg.src = photoUrlWithCache;
      }
    }
    
    // Atualizar no modal de detalhes
    const detailPhoto = document.getElementById(`detail-photo-${recipeId}`);
    if (detailPhoto && detailPhoto.tagName === 'IMG') {
      detailPhoto.src = photoUrlWithCache;
    }
    
    // Atualizar estado global para pr√≥xima edi√ß√£o
    if (window.currentRecipeCropData) {
      window.currentRecipeCropData.crop_x = imageEditorState.posX;
      window.currentRecipeCropData.crop_y = imageEditorState.posY;
    }
  }

  // Atualizar foto da receita
  window.updateRecipePhoto = async function(recipeId, file) {
    if (!file) return;

    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      const formData = new FormData();
      formData.append('photo', file);

      const response = await fetch(`/recipes/${recipeId}`, {
        method: 'PUT',
        headers: {
          'X-CSRF-Token': csrfToken
        },
        body: formData
      });

      const data = await response.json();

      if (data.success) {
        window.showToast('Foto atualizada!');
        setTimeout(() => location.reload(), 800);
      } else {
        throw new Error(data.error || 'Erro ao atualizar foto');
      }
    } catch (error) {
      console.error('Erro:', error);
      window.showToast(error.message || 'Erro ao atualizar foto', 'error');
    }
  };
})();
</script>
