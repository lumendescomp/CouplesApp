<div class="space-y-6">
  <header class="flex items-center justify-between">
    <h1 class="page-title text-2xl font-semibold text-violet-100">Nosso √°lbum</h1>
    <div class="text-sm text-violet-300"><%= photos.length %>/20 fotos</div>
  </header>

  <!-- Biblioteca de fotos -->
  <section
    class="glass rounded-xl border border-violet-700/40 bg-white/5 p-4 relative"
  >
    <!-- Modal de Confirma√ß√£o da Biblioteca -->
    <div
      id="confirm-modal-library"
      class="absolute inset-0 bg-black/60 backdrop-blur-sm z-50 rounded-xl flex items-center justify-center hidden"
      style="transition: opacity 0.3s ease"
    >
      <div
        class="glass rounded-2xl border border-violet-700/40 bg-gradient-to-br from-violet-900/90 to-fuchsia-900/90 p-6 max-w-md w-full mx-4 shadow-2xl"
        style="transform: scale(0.9); transition: transform 0.3s ease"
      >
        <div class="flex items-start gap-4 mb-4">
          <div
            class="flex-shrink-0 w-12 h-12 rounded-full bg-red-500/20 flex items-center justify-center"
          >
            <svg
              class="w-6 h-6 text-red-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>
          <div class="flex-1">
            <h3 class="text-lg font-semibold text-violet-100 mb-2">
              Confirmar a√ß√£o
            </h3>
            <p
              id="confirm-message-library"
              class="text-violet-200/80 text-sm"
            ></p>
          </div>
        </div>
        <div class="flex gap-3 justify-end">
          <button
            id="confirm-cancel-library"
            class="px-4 py-2 rounded-lg bg-violet-700/30 hover:bg-violet-700/50 text-violet-100 transition-colors"
          >
            Cancelar
          </button>
          <button
            id="confirm-ok-library"
            class="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white transition-colors"
          >
            Confirmar
          </button>
        </div>
      </div>
    </div>

    <div class="flex items-center justify-between mb-4">
      <h2 class="text-lg font-medium text-violet-100">
        Biblioteca de Mem√≥rias
      </h2>

      <label
        id="upload-label"
        class="btn-heart px-4 py-2 rounded-full cursor-pointer inline-flex items-center gap-2"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          class="w-4 h-4"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M12 4v16m8-8H4"
          />
        </svg>
        <span id="upload-text">Adicionar M√≠dia</span>
        <input
          type="file"
          name="photo"
          accept="image/*,video/mp4,video/webm,video/quicktime"
          multiple
          class="hidden"
          id="photo-input"
        />
      </label>
    </div>

    <!-- Carrossel de fotos -->
    <div class="relative group">
      <!-- Bot√£o esquerdo -->
      <button
        id="carousel-prev"
        class="absolute left-0 top-1/2 -translate-y-1/2 z-10 bg-violet-600/80 hover:bg-violet-600 text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity disabled:opacity-0 disabled:cursor-not-allowed"
        aria-label="Anterior"
      >
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M15 19l-7-7 7-7"
          />
        </svg>
      </button>

      <!-- Container do carrossel -->
      <div
        id="photos-carousel"
        class="flex gap-3 overflow-x-auto scroll-smooth snap-x snap-mandatory"
      >
        <% if (photos.length === 0) { %>
        <div class="w-full text-center text-violet-300/80 py-8 px-4">
          Nenhuma foto ainda. Adicione suas primeiras mem√≥rias! üíï
        </div>
        <% } %> <% photos.forEach(photo => { %> <%- include('_photo_item', {
        photo }) %> <% }) %>
      </div>

      <!-- Bot√£o direito -->
      <button
        id="carousel-next"
        class="absolute right-0 top-1/2 -translate-y-1/2 z-10 bg-violet-600/80 hover:bg-violet-600 text-white p-2 rounded-full opacity-0 group-hover:opacity-100 transition-opacity disabled:opacity-0 disabled:cursor-not-allowed"
        aria-label="Pr√≥ximo"
      >
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9 5l7 7-7 7"
          />
        </svg>
      </button>
    </div>
  </section>

  <!-- Template de cora√ß√£o com 6 slots -->
  <section
    class="glass rounded-xl border border-violet-700/40 bg-white/5 p-6 relative"
  >
    <!-- Modal de Confirma√ß√£o dos Slots -->
    <div
      id="confirm-modal-slots"
      class="absolute inset-0 bg-black/60 backdrop-blur-sm z-50 rounded-xl flex items-center justify-center hidden"
      style="transition: opacity 0.3s ease"
    >
      <div
        class="glass rounded-2xl border border-violet-700/40 bg-gradient-to-br from-violet-900/90 to-fuchsia-900/90 p-6 max-w-md w-full mx-4 shadow-2xl"
        style="transform: scale(0.9); transition: transform 0.3s ease"
      >
        <div class="flex items-start gap-4 mb-4">
          <div
            class="flex-shrink-0 w-12 h-12 rounded-full bg-red-500/20 flex items-center justify-center"
          >
            <svg
              class="w-6 h-6 text-red-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>
          <div class="flex-1">
            <h3 class="text-lg font-semibold text-violet-100 mb-2">
              Confirmar a√ß√£o
            </h3>
            <p
              id="confirm-message-slots"
              class="text-violet-200/80 text-sm"
            ></p>
          </div>
        </div>
        <div class="flex gap-3 justify-end">
          <button
            id="confirm-cancel-slots"
            class="px-4 py-2 rounded-lg bg-violet-700/30 hover:bg-violet-700/50 text-violet-100 transition-colors"
          >
            Cancelar
          </button>
          <button
            id="confirm-ok-slots"
            class="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white transition-colors"
          >
            Confirmar
          </button>
        </div>
      </div>
    </div>

    <h2 class="text-lg font-medium text-violet-100 mb-4">
      Cora√ß√£o de Mem√≥rias ‚ú®
    </h2>

    <div class="relative mx-auto max-w-2xl">
      <!-- SVG do template em formato de cora√ß√£o -->
      <div class="album-template" id="album-template">
        <!-- Slot 1 - Topo esquerdo -->
        <div
          class="album-slot"
          data-slot="1"
          style="
            position: absolute;
            top: 15%;
            left: 15%;
            width: 120px;
            height: 120px;
          "
        >
          <% if (slots[1]) { %> <%- include('_slot_filled', { slotNumber: 1,
          filePath: slots[1].file_path, photoId: slots[1].photo_id, mediaType:
          slots[1].media_type }) %> <% } else { %> <%- include('_slot_empty', {
          slotNumber: 1 }) %> <% } %>
        </div>

        <!-- Slot 2 - Topo direito -->
        <div
          class="album-slot"
          data-slot="2"
          style="
            position: absolute;
            top: 15%;
            right: 15%;
            width: 120px;
            height: 120px;
          "
        >
          <% if (slots[2]) { %> <%- include('_slot_filled', { slotNumber: 2,
          filePath: slots[2].file_path, photoId: slots[2].photo_id, mediaType:
          slots[2].media_type }) %> <% } else { %> <%- include('_slot_empty', {
          slotNumber: 2 }) %> <% } %>
        </div>

        <!-- Slot 3 - Centro esquerdo -->
        <div
          class="album-slot"
          data-slot="3"
          style="
            position: absolute;
            top: 45%;
            left: 10%;
            width: 140px;
            height: 140px;
          "
        >
          <% if (slots[3]) { %> <%- include('_slot_filled', { slotNumber: 3,
          filePath: slots[3].file_path, photoId: slots[3].photo_id, mediaType:
          slots[3].media_type }) %> <% } else { %> <%- include('_slot_empty', {
          slotNumber: 3 }) %> <% } %>
        </div>

        <!-- Slot 4 - Centro direito -->
        <div
          class="album-slot"
          data-slot="4"
          style="
            position: absolute;
            top: 45%;
            right: 10%;
            width: 140px;
            height: 140px;
          "
        >
          <% if (slots[4]) { %> <%- include('_slot_filled', { slotNumber: 4,
          filePath: slots[4].file_path, photoId: slots[4].photo_id, mediaType:
          slots[4].media_type }) %> <% } else { %> <%- include('_slot_empty', {
          slotNumber: 4 }) %> <% } %>
        </div>

        <!-- Slot 5 - Base esquerdo -->
        <div
          class="album-slot"
          data-slot="5"
          style="
            position: absolute;
            bottom: 10%;
            left: 25%;
            width: 110px;
            height: 110px;
          "
        >
          <% if (slots[5]) { %> <%- include('_slot_filled', { slotNumber: 5,
          filePath: slots[5].file_path, photoId: slots[5].photo_id, mediaType:
          slots[5].media_type }) %> <% } else { %> <%- include('_slot_empty', {
          slotNumber: 5 }) %> <% } %>
        </div>

        <!-- Slot 6 - Base direito -->
        <div
          class="album-slot"
          data-slot="6"
          style="
            position: absolute;
            bottom: 10%;
            right: 25%;
            width: 110px;
            height: 110px;
          "
        >
          <% if (slots[6]) { %> <%- include('_slot_filled', { slotNumber: 6,
          filePath: slots[6].file_path, photoId: slots[6].photo_id, mediaType:
          slots[6].media_type }) %> <% } else { %> <%- include('_slot_empty', {
          slotNumber: 6 }) %> <% } %>
        </div>

        <!-- Fundo decorativo (cora√ß√£o) -->
        <svg
          viewBox="0 0 100 100"
          class="absolute inset-0 w-full h-full opacity-10 pointer-events-none"
          style="z-index: -1"
        >
          <path
            d="M50,90 C50,90 10,60 10,35 C10,20 20,10 30,10 C40,10 50,20 50,30 C50,20 60,10 70,10 C80,10 90,20 90,35 C90,60 50,90 50,90 Z"
            fill="currentColor"
            class="text-fuchsia-500/30"
          />
        </svg>
      </div>
    </div>
  </section>
</div>

<style>
  .album-template {
    position: relative;
    width: 100%;
    padding-bottom: 100%; /* Aspect ratio 1:1 */
  }

  .album-slot {
    border-radius: 12px;
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .album-slot.drag-over {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(232, 121, 249, 0.5);
  }

  .photo-library-item {
    cursor: grab;
    transition: transform 0.2s ease;
  }

  .photo-library-item:active {
    cursor: grabbing;
  }

  .photo-library-item:hover {
    transform: scale(1.05);
  }

  /* Controle individual do overlay de deletar */
  .photo-item-individual:hover .photo-delete-overlay {
    opacity: 1;
  }

  /* Overlay nunca deve interferir no drag - apenas o bot√£o √© clic√°vel */
  .photo-delete-overlay {
    pointer-events: none;
  }

  .photo-delete-overlay .photo-delete-btn {
    pointer-events: auto;
  }

  /* Durante drag, esconde overlay para evitar conflitos */
  .photo-library-item[style*="opacity: 0.5"] .photo-delete-overlay {
    display: none !important;
  }

  /* Scrollbar customizada e vis√≠vel */
  #photos-carousel::-webkit-scrollbar {
    height: 8px;
  }

  #photos-carousel::-webkit-scrollbar-track {
    background: rgba(139, 92, 246, 0.1);
    border-radius: 10px;
  }

  #photos-carousel::-webkit-scrollbar-thumb {
    background: rgba(139, 92, 246, 0.6);
    border-radius: 10px;
    transition: background 0.3s;
  }

  #photos-carousel::-webkit-scrollbar-thumb:hover {
    background: rgba(139, 92, 246, 0.8);
  }

  #photos-carousel {
    -ms-overflow-style: auto; /* Mostra scrollbar no IE/Edge */
    scrollbar-width: thin; /* Firefox: scrollbar fina */
    scrollbar-color: rgba(139, 92, 246, 0.6) rgba(139, 92, 246, 0.1); /* Firefox: cor do thumb e track */
    cursor: grab;
    scroll-behavior: smooth;
    padding-bottom: 12px; /* Espa√ßo para scrollbar */
  }

  #photos-carousel:active {
    cursor: grabbing;
    scroll-behavior: auto; /* Desativa smooth durante drag manual */
  }

  /* Feedback visual durante drag do carrossel */
  #photos-carousel.dragging {
    cursor: grabbing;
    user-select: none;
  }

  #photos-carousel.dragging .photo-library-item {
    pointer-events: none; /* Previne iniciar drag de foto durante scroll */
  }
</style>

<script>
  /**
   * ========================================================================
   * √ÅLBUM DE FOTOS - SCRIPT PRINCIPAL
   * ========================================================================
   * 
   * Este script gerencia todas as intera√ß√µes da p√°gina de √°lbum:
   * - Upload de fotos/v√≠deos
   * - Carrossel com scroll manual e bot√µes
   * - Drag & Drop da biblioteca para slots do cora√ß√£o
   * - Remo√ß√£o de fotos da biblioteca e slots
   * - Carregamento lazy de imagens
   * - Modais de confirma√ß√£o
   * 
   * Chamado automaticamente quando a p√°gina /album √© carregada.
   */

  (function AlbumPage() {
    // Token CSRF para prote√ß√£o contra ataques CSRF
    const CSRF =
      (document.querySelector('meta[name="csrf-token"]') || {}).content || "";

    /**
     * ========================================================================
     * MODAL DE CONFIRMA√á√ÉO - BIBLIOTECA
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - Ao clicar no bot√£o de deletar uma foto da biblioteca
     * 
     * O QUE FAZ:
     * - Exibe um modal estilizado pedindo confirma√ß√£o
     * - Retorna uma Promise que resolve com true (confirmou) ou false (cancelou)
     * - Pode ser fechado clicando em "Cancelar", "X", fora do modal ou ESC
     */
    function showConfirmLibrary(message) {
      return new Promise((resolve) => {
        const modal = document.getElementById("confirm-modal-library");
        const messageEl = document.getElementById("confirm-message-library");
        const okBtn = document.getElementById("confirm-ok-library");
        const cancelBtn = document.getElementById("confirm-cancel-library");

        // Define a mensagem do modal
        messageEl.textContent = message;
        
        // Remove a classe 'hidden' para mostrar o modal
        modal.classList.remove("hidden");

        // Anima√ß√£o de entrada (fade in + scale)
        setTimeout(() => {
          modal.style.opacity = "1";
          modal.querySelector("div > div").style.transform = "scale(1)";
        }, 10);

        /**
         * Fun√ß√£o interna para fechar o modal com anima√ß√£o
         * @param {boolean} result - true se confirmou, false se cancelou
         */
        function close(result) {
          // Anima√ß√£o de sa√≠da (fade out + scale down)
          modal.style.opacity = "0";
          modal.querySelector("div > div").style.transform = "scale(0.9)";
          
          // Aguarda anima√ß√£o terminar antes de esconder
          setTimeout(() => {
            modal.classList.add("hidden");
            resolve(result); // Resolve a Promise com o resultado
          }, 300);
        }

        // Bot√£o OK: fecha e retorna true
        okBtn.onclick = () => close(true);
        
        // Bot√£o Cancelar: fecha e retorna false
        cancelBtn.onclick = () => close(false);

        // Clicar fora do modal: fecha e retorna false
        modal.onclick = (e) => {
          if (e.target === modal) close(false);
        };

        // Tecla ESC: fecha e retorna false
        const escHandler = (e) => {
          if (e.key === "Escape") {
            close(false);
            document.removeEventListener("keydown", escHandler);
          }
        };
        document.addEventListener("keydown", escHandler);
      });
    }

    /**
     * ========================================================================
     * MODAL DE CONFIRMA√á√ÉO - SLOTS
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - Ao clicar no bot√£o de remover uma foto de um slot do cora√ß√£o
     * 
     * O QUE FAZ:
     * - Exibe um modal estilizado pedindo confirma√ß√£o
     * - Retorna uma Promise que resolve com true (confirmou) ou false (cancelou)
     * - Id√™ntico ao modal da biblioteca, mas com IDs diferentes
     */
    function showConfirmSlots(message) {
      return new Promise((resolve) => {
        const modal = document.getElementById("confirm-modal-slots");
        const messageEl = document.getElementById("confirm-message-slots");
        const okBtn = document.getElementById("confirm-ok-slots");
        const cancelBtn = document.getElementById("confirm-cancel-slots");

        messageEl.textContent = message;
        modal.classList.remove("hidden");

        setTimeout(() => {
          modal.style.opacity = "1";
          modal.querySelector("div > div").style.transform = "scale(1)";
        }, 10);

        function close(result) {
          modal.style.opacity = "0";
          modal.querySelector("div > div").style.transform = "scale(0.9)";
          setTimeout(() => {
            modal.classList.add("hidden");
            resolve(result);
          }, 300);
        }

        okBtn.onclick = () => close(true);
        cancelBtn.onclick = () => close(false);

        modal.onclick = (e) => {
          if (e.target === modal) close(false);
        };

        const escHandler = (e) => {
          if (e.key === "Escape") {
            close(false);
            document.removeEventListener("keydown", escHandler);
          }
        };
        document.addEventListener("keydown", escHandler);
      });
    }

    /**
     * ========================================================================
     * CONTROLES DO CARROSSEL
     * ========================================================================
     */

    const carousel = document.getElementById("photos-carousel");
    const prevBtn = document.getElementById("carousel-prev");
    const nextBtn = document.getElementById("carousel-next");

    /**
     * Atualiza o estado (enabled/disabled) dos bot√µes do carrossel
     * 
     * QUANDO √â CHAMADO:
     * - No carregamento inicial da p√°gina
     * - Sempre que o usu√°rio scrolla o carrossel
     * - Ap√≥s adicionar ou remover fotos
     * 
     * O QUE FAZ:
     * - Desabilita bot√£o esquerdo se estiver no in√≠cio
     * - Desabilita bot√£o direito se estiver no final
     */
    function updateCarouselButtons() {
      if (!carousel || !prevBtn || !nextBtn) return;

      const scrollLeft = carousel.scrollLeft;
      const scrollWidth = carousel.scrollWidth;
      const clientWidth = carousel.clientWidth;

      // Desabilita bot√£o esquerdo se estiver no in√≠cio
      prevBtn.disabled = scrollLeft <= 0;

      // Desabilita bot√£o direito se estiver no final (com margem de 10px)
      nextBtn.disabled = scrollLeft + clientWidth >= scrollWidth - 10;
    }

    if (carousel && prevBtn && nextBtn) {
      /**
       * BOT√ÉO PREV (Voltar):
       * Scrolla 300px para a esquerda com anima√ß√£o suave
       */
      prevBtn.addEventListener("click", () => {
        carousel.scrollBy({ left: -300, behavior: "smooth" });
      });

      /**
       * BOT√ÉO NEXT (Avan√ßar):
       * Scrolla 300px para a direita com anima√ß√£o suave
       */
      nextBtn.addEventListener("click", () => {
        carousel.scrollBy({ left: 300, behavior: "smooth" });
      });

      /**
       * EVENT LISTENER: scroll
       * Atualiza estado dos bot√µes sempre que o carrossel scrolla
       */
      carousel.addEventListener("scroll", updateCarouselButtons);

      // Atualiza estado inicial dos bot√µes
      updateCarouselButtons();

      /**
       * ========================================================================
       * DRAG TO SCROLL - MOUSE
       * ========================================================================
       * 
       * QUANDO √â USADO:
       * - Usu√°rio clica e arrasta dentro do carrossel (mas n√£o em uma foto)
       * 
       * O QUE FAZ:
       * - Permite scrollar o carrossel arrastando com o mouse
       * - Desabilita sele√ß√£o de texto durante o arrasto
       * - Muda cursor para "grabbing"
       */

      let isDragging = false; // Flag: est√° arrastando?
      let startX; // Posi√ß√£o X inicial do mouse
      let scrollLeftStart; // Posi√ß√£o inicial do scroll

      /**
       * Mouse pressionado: inicia drag to scroll
       */
      carousel.addEventListener("mousedown", (e) => {
        // Ignora se clicou em uma foto (para n√£o interferir com drag de foto)
        if (e.target.closest(".photo-library-item")) return;

        isDragging = true;
        carousel.classList.add("dragging");
        carousel.style.cursor = "grabbing";
        carousel.style.userSelect = "none"; // Desabilita sele√ß√£o de texto
        
        startX = e.pageX - carousel.offsetLeft;
        scrollLeftStart = carousel.scrollLeft;
      });

      /**
       * Mouse sai do carrossel: cancela drag
       */
      carousel.addEventListener("mouseleave", () => {
        isDragging = false;
        carousel.classList.remove("dragging");
        carousel.style.cursor = "grab";
      });

      /**
       * Mouse solto: finaliza drag
       */
      carousel.addEventListener("mouseup", () => {
        isDragging = false;
        carousel.classList.remove("dragging");
        carousel.style.cursor = "grab";
      });

      /**
       * Mouse movendo: scrolla o carrossel
       */
      carousel.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const x = e.pageX - carousel.offsetLeft;
        const walk = (x - startX) * 2; // Multiplicador = velocidade do scroll
        carousel.scrollLeft = scrollLeftStart - walk;
      });

      /**
       * ========================================================================
       * DRAG TO SCROLL - TOUCH (Mobile)
       * ========================================================================
       * 
       * QUANDO √â USADO:
       * - Usu√°rio arrasta com o dedo em dispositivos touch
       * 
       * O QUE FAZ:
       * - Mesma funcionalidade do drag com mouse, mas para telas touch
       */

      let touchStartX; // Posi√ß√£o X inicial do toque
      let touchScrollLeft; // Posi√ß√£o inicial do scroll

      carousel.addEventListener("touchstart", (e) => {
        if (e.target.closest(".photo-library-item")) return;
        touchStartX = e.touches[0].pageX;
        touchScrollLeft = carousel.scrollLeft;
      });

      carousel.addEventListener("touchmove", (e) => {
        if (!touchStartX) return;
        const x = e.touches[0].pageX;
        const walk = (touchStartX - x) * 1.5;
        carousel.scrollLeft = touchScrollLeft + walk;
      });

      carousel.addEventListener("touchend", () => {
        touchStartX = null;
      });
    }

    /**
     * ========================================================================
     * UPLOAD DE FOTOS/V√çDEOS
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - Usu√°rio seleciona arquivos no input file
     * 
     * O QUE FAZ:
     * 1. Desabilita bot√£o e mostra "Enviando..."
     * 2. Faz upload de cada arquivo individualmente via fetch
     * 3. Adiciona novo item no IN√çCIO do carrossel (HTML retornado pelo servidor)
     * 4. Atualiza contador de fotos
     * 5. Re-inicializa drag, delete e lazy loading
     * 6. Mostra toast de sucesso
     */

    const photoInput = document.getElementById("photo-input");
    const uploadLabel = document.getElementById("upload-label");
    const uploadText = document.getElementById("upload-text");

    if (photoInput) {
      photoInput.addEventListener("change", async function () {
        if (!this.files || this.files.length === 0) return;

        const files = Array.from(this.files);
        let uploadedCount = 0;
        let failedCount = 0;
        let videoCount = 0;
        let photoCount = 0;

        // Desabilita bot√£o durante upload
        uploadLabel.style.opacity = "0.6";
        uploadLabel.style.pointerEvents = "none";
        uploadText.textContent = `Enviando... 0/${files.length}`;

        // Loop: upload de cada arquivo individualmente
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          const formData = new FormData();
          formData.append("photo", file);

          try {
            // Fetch POST para /album/upload
            const response = await fetch("/album/upload", {
              method: "POST",
              body: formData,
              credentials: "same-origin",
            });

            if (response.ok) {
              // Servidor retorna HTML do novo item de foto
              const html = await response.text();

              // Insere no IN√çCIO do carrossel
              const photosCarousel = document.getElementById("photos-carousel");
              photosCarousel.insertAdjacentHTML("afterbegin", html);

              // Conta se √© v√≠deo ou foto
              const isVideo = file.type.startsWith("video/");
              if (isVideo) {
                videoCount++;
              } else {
                photoCount++;
              }

              uploadedCount++;
              uploadText.textContent = `Enviando... ${uploadedCount}/${files.length}`;
            } else {
              const errorData = await response.json();
              console.error(`Erro ao fazer upload de ${file.name}:`, errorData.error);
              failedCount++;
            }
          } catch (error) {
            console.error(`Erro no upload de ${file.name}:`, error);
            failedCount++;
          }
        }

        // Restaura bot√£o
        uploadLabel.style.opacity = "1";
        uploadLabel.style.pointerEvents = "auto";
        uploadText.textContent = "Adicionar m√≠dia";

        // Se houve sucesso, atualiza a p√°gina
        if (uploadedCount > 0) {
          // Atualiza contador "X/20 fotos"
          const counter = document.querySelector("header .text-sm");
          const currentCount = parseInt(counter.textContent.match(/\d+/)[0]);
          counter.textContent = `${currentCount + uploadedCount}/20 fotos`;

          // Volta carrossel para o in√≠cio (onde est√£o as novas fotos)
          carousel.scrollTo({ left: 0, behavior: "smooth" });

          // Re-inicializa funcionalidades nas novas fotos
          initDragDrop();
          initPhotoDelete();
          initLazyLoading();

          // Atualiza bot√µes do carrossel
          updateCarouselButtons();
        }

        // Limpa input para permitir re-upload do mesmo arquivo
        photoInput.value = "";

        // Mostra toast de resultado
        if (uploadedCount > 0 && failedCount === 0) {
          let message = "‚úÖ ";
          const parts = [];

          if (photoCount > 0) {
            parts.push(`${photoCount} foto${photoCount > 1 ? "s" : ""}`);
          }
          if (videoCount > 0) {
            parts.push(`${videoCount} v√≠deo${videoCount > 1 ? "s" : ""}`);
          }

          message +=
            parts.join(" e ") +
            " adicionado" +
            (uploadedCount > 1 ? "s" : "") +
            "!";
          window.showToast(message);
        } else if (failedCount > 0) {
          window.showToast(
            `${uploadedCount} m√≠dia(s) adicionada(s), ${failedCount} falhou(aram).`,
            "error"
          );
        }
      });
    }

    /**
     * ========================================================================
     * DRAG & DROP - BIBLIOTECA ‚Üí SLOTS
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - No carregamento inicial
     * - Ap√≥s adicionar novas fotos
     * - Ap√≥s HTMX swap (navega√ß√£o)
     * 
     * O QUE FAZ:
     * 1. Torna fotos da biblioteca arrast√°veis (draggable=true)
     * 2. Torna slots do cora√ß√£o receptivos (dragover, drop)
     * 3. Ao soltar foto em um slot:
     *    - Faz POST /album/slot/:number com photo_id
     *    - Atualiza HTML do slot com resposta do servidor
     *    - Re-inicializa eventos de remo√ß√£o
     */
    function initDragDrop() {
      /**
       * PARTE 1: Tornar fotos arrast√°veis
       */
      document.querySelectorAll(".photo-library-item").forEach((item) => {
        item.draggable = true;

        /**
         * In√≠cio do arrasto:
         * - Armazena photo-id no dataTransfer
         * - Deixa foto semi-transparente
         * - Esconde overlay de delete
         */
        item.addEventListener("dragstart", (e) => {
          e.dataTransfer.effectAllowed = "copy";
          e.dataTransfer.setData("photo-id", item.dataset.photoId);
          item.style.opacity = "0.5";

          const overlay = item.querySelector(".photo-delete-overlay");
          if (overlay) {
            overlay.style.display = "none";
          }
        });

        /**
         * Fim do arrasto:
         * - Restaura opacidade
         * - Mostra overlay de delete novamente
         */
        item.addEventListener("dragend", (e) => {
          item.style.opacity = "1";

          const overlay = item.querySelector(".photo-delete-overlay");
          if (overlay) {
            overlay.style.display = "flex";
          }
        });
      });

      /**
       * PARTE 2: Tornar slots receptivos
       */
      document.querySelectorAll(".album-slot").forEach((slot) => {
        /**
         * Passando por cima do slot:
         * - Adiciona classe 'drag-over' (feedback visual)
         */
        slot.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "copy";
          slot.classList.add("drag-over");
        });

        /**
         * Saiu do slot sem soltar:
         * - Remove classe 'drag-over'
         */
        slot.addEventListener("dragleave", (e) => {
          slot.classList.remove("drag-over");
        });

        /**
         * Soltou foto no slot:
         * 1. Pega photo_id do dataTransfer
         * 2. POST /album/slot/:number
         * 3. Atualiza HTML do slot
         * 4. Re-inicializa bot√£o de remo√ß√£o
         */
        slot.addEventListener("drop", async (e) => {
          e.preventDefault();
          slot.classList.remove("drag-over");

          const photoId = e.dataTransfer.getData("photo-id");
          const slotNumber = slot.dataset.slot;

          if (!photoId || !slotNumber) return;

          try {
            const res = await fetch(`/album/slot/${slotNumber}`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRF-Token": CSRF,
                "HX-Request": "true",
              },
              body: JSON.stringify({ photo_id: parseInt(photoId) }),
            });

            if (res.ok) {
              const html = await res.text();
              slot.innerHTML = html;
              
              // Re-inicializar eventos de remo√ß√£o
              initSlotRemoval();

              // Mostra toast apropriado
              const draggedItem = document.querySelector(`[data-photo-id="${photoId}"]`);
              const isVideo = draggedItem && draggedItem.dataset.mediaType === "video";
              const mediaType = isVideo ? "V√≠deo" : "Foto";

              window.showToast(`${mediaType} adicionado ao slot!`);
            } else {
              window.showToast("Erro ao adicionar m√≠dia", "error");
            }
          } catch (err) {
            console.error(err);
            window.showToast("Erro ao adicionar m√≠dia", "error");
          }
        });
      });
    }

    /**
     * ========================================================================
     * REMO√á√ÉO DE SLOT
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - No carregamento inicial
     * - Ap√≥s adicionar foto a um slot
     * - Ap√≥s HTMX swap
     * 
     * O QUE FAZ:
     * - Adiciona event listener aos bot√µes de remo√ß√£o dos slots
     * - Ao clicar:
     *   1. Mostra modal de confirma√ß√£o
     *   2. DELETE /album/slot/:number
     *   3. Substitui HTML do slot por slot vazio
     */
    function initSlotRemoval() {
      document.querySelectorAll(".slot-remove-btn").forEach((btn) => {
        btn.onclick = async (e) => {
          e.preventDefault();
          e.stopPropagation();

          const slotNumber = btn.dataset.slot;
          
          // Pede confirma√ß√£o
          const confirmed = await showConfirmSlots("Remover m√≠dia deste slot?");
          if (!confirmed) return;

          try {
            const res = await fetch(`/album/slot/${slotNumber}`, {
              method: "DELETE",
              headers: {
                "X-CSRF-Token": CSRF,
                "HX-Request": "true",
              },
            });

            if (res.ok) {
              // Servidor retorna HTML do slot vazio
              const html = await res.text();
              const slot = document.querySelector(`.album-slot[data-slot="${slotNumber}"]`);
              if (slot) {
                slot.innerHTML = html;
              }
              window.showToast("M√≠dia removida");
            }
          } catch (err) {
            console.error(err);
          }
        };
      });
    }

    /**
     * ========================================================================
     * DELETAR FOTO DA BIBLIOTECA
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - No carregamento inicial
     * - Ap√≥s adicionar novas fotos
     * - Ap√≥s HTMX swap
     * 
     * O QUE FAZ:
     * - Adiciona event listener aos bot√µes de delete das fotos
     * - Ao clicar:
     *   1. Mostra modal de confirma√ß√£o
     *   2. DELETE /album/photo/:id
     *   3. Remove item da biblioteca com anima√ß√£o
     *   4. Limpa slots que continham essa foto
     *   5. Mant√©m posi√ß√£o do scroll do carrossel
     */
    function initPhotoDelete() {
      document.querySelectorAll(".photo-delete-btn").forEach((btn) => {
        btn.onclick = async (e) => {
          e.preventDefault();
          e.stopPropagation();

          const photoId = btn.dataset.photoId;
          
          // Pede confirma√ß√£o
          const confirmed = await showConfirmLibrary(
            "Deletar esta m√≠dia? Ela ser√° removida de todos os slots."
          );
          if (!confirmed) return;

          // Salva posi√ß√£o do scroll (para manter ap√≥s deletar)
          const carousel = document.getElementById("photos-carousel");
          const scrollPosition = carousel ? carousel.scrollLeft : 0;

          try {
            const res = await fetch(`/album/photo/${photoId}`, {
              method: "DELETE",
              headers: {
                "X-CSRF-Token": CSRF,
                "HX-Request": "true",
              },
            });

            if (res.ok) {
              // Remove item com anima√ß√£o fade out + scale down
              const item = btn.closest(".photo-library-item");
              if (item) {
                item.style.transition = "opacity 0.3s, transform 0.3s";
                item.style.opacity = "0";
                item.style.transform = "scale(0.8)";
                setTimeout(() => item.remove(), 300);
              }

              // Limpa slots que tinham essa foto
              clearSlotsWithPhoto(photoId);

              // Restaura posi√ß√£o do scroll
              setTimeout(() => {
                if (carousel) {
                  carousel.scrollLeft = scrollPosition;
                }
              }, 350);

              // Atualiza bot√µes do carrossel
              updateCarouselButtons();

              window.showToast("M√≠dia deletada com sucesso!");
            }
          } catch (err) {
            console.error(err);
            window.showToast("Erro ao deletar m√≠dia", "error");
          }
        };
      });
    }

    /**
     * ========================================================================
     * LIMPAR SLOTS COM FOTO DELETADA
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - Ap√≥s deletar uma foto da biblioteca
     * 
     * O QUE FAZ:
     * - Percorre todos os slots
     * - Se o slot cont√©m a foto deletada (verifica data-photo-id em img/video)
     * - Transforma o slot em slot vazio (apenas borda tracejada + n√∫mero)
     * 
     * @param {string} photoId - ID da foto que foi deletada
     */
    function clearSlotsWithPhoto(photoId) {
      const slots = document.querySelectorAll(".album-slot");

      slots.forEach((slot) => {
        // Verifica se tem img OU video com o photo-id
        const img = slot.querySelector(`img[data-photo-id="${photoId}"]`);
        const video = slot.querySelector(`video[data-photo-id="${photoId}"]`);

        if (img || video) {
          // Transforma em slot vazio
          const slotNumber = slot.dataset.slot;
          slot.innerHTML = `
            <div class="w-full h-full rounded-lg border-2 border-dashed border-violet-700/50 bg-violet-900/10 flex items-center justify-center text-violet-300/60 text-xs">
              ${slotNumber}
            </div>
          `;
          slot.classList.add("empty-slot");
        }
      });
    }

    /**
     * ========================================================================
     * LAZY LOADING DE IMAGENS/V√çDEOS
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - No carregamento inicial
     * - Ap√≥s adicionar novas fotos
     * - Ap√≥s HTMX swap
     * 
     * O QUE FAZ:
     * - Usa Intersection Observer para carregar imagens apenas quando vis√≠veis
     * - Elementos t√™m atributo data-src (ao inv√©s de src)
     * - Quando entram na viewport:
     *   1. Copia data-src para src
     *   2. Remove data-src
     *   3. Fade in (opacity 0 ‚Üí 1)
     *   4. Para de observar o elemento
     */

    // Observer global (para poder desconectar no cleanup)
    let mediaObserver = null;

    function initLazyLoading() {
      console.log("[Album] initLazyLoading chamado");

      const container = document.querySelector("#photos-carousel");
      if (!container) {
        console.log("[Album] Container n√£o encontrado");
        return;
      }

      // Cria Intersection Observer
      mediaObserver = new IntersectionObserver(
        (entries, observer) => {
          entries.forEach((entry) => {
            // Elemento est√° vis√≠vel?
            if (entry.isIntersecting) {
              const element = entry.target;
              const src = element.getAttribute("data-src");

              if (src) {
                console.log("[Album] Carregando:", src);

                if (element.tagName === "VIDEO") {
                  /**
                   * V√çDEOS:
                   * 1. Define src
                   * 2. Espera 'loadeddata' event
                   * 3. Fade in
                   * 4. Inicia reprodu√ß√£o (autoplay)
                   */
                  element.style.opacity = "0";
                  
                  element.addEventListener("loadeddata", () => {
                    setTimeout(() => {
                      element.style.opacity = "1";
                    }, 10);
                    element.play().catch(() => {
                      // Ignora erros de autoplay (pol√≠ticas do browser)
                    });
                  }, { once: true });

                  element.addEventListener("error", () => {
                    console.log("[Album] Erro ao carregar v√≠deo:", src);
                  }, { once: true });

                  element.src = src;
                  element.removeAttribute("data-src");
                  element.classList.remove("lazy-image");
                  observer.unobserve(element);

                } else {
                  /**
                   * IMAGENS:
                   * 1. Define src DIRETAMENTE no elemento (sem new Image)
                   * 2. Espera 'load' event
                   * 3. Fade in
                   */
                  element.style.opacity = "0";

                  const onLoad = () => {
                    setTimeout(() => {
                      element.style.opacity = "1";
                    }, 10);
                  };

                  const onError = () => {
                    console.log("[Album] Erro ao carregar:", src);
                  };

                  element.addEventListener("load", onLoad, { once: true });
                  element.addEventListener("error", onError, { once: true });
                  
                  element.src = src;
                  element.removeAttribute("data-src");
                  element.classList.remove("lazy-image");
                  observer.unobserve(element);
                }
              }
            }
          });
        },
        {
          rootMargin: "200px", // Come√ßa a carregar 200px antes de entrar na tela
          threshold: 0.01, // Trigger quando 1% do elemento estiver vis√≠vel
        }
      );

      // Observa todas as imagens e v√≠deos com classe 'lazy-image'
      const lazyElements = document.querySelectorAll(".lazy-image");
      console.log("[Album] Observando", lazyElements.length, "elementos lazy");
      
      lazyElements.forEach((element) => {
        mediaObserver.observe(element);
      });
    }

    /**
     * ========================================================================
     * CLEANUP - LIMPEZA AO SAIR DA P√ÅGINA
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - Quando o usu√°rio navega para outra p√°gina (via HTMX)
     * - Detectado pelo evento htmx:beforeRequest
     * 
     * O QUE FAZ:
     * 1. Desconecta Intersection Observer
     * 2. Pausa e cancela carregamento de todos os v√≠deos
     * 3. Cancela carregamento de todas as imagens
     * 4. Limpa flags e tracking
     * 
     * POR QU√ä?
     * - Evita memory leaks
     * - Cancela requisi√ß√µes HTTP em andamento
     * - Libera recursos do browser
     */
    function cleanupAlbum() {
      console.log("[Album] ‚ö†Ô∏è CLEANUP INICIADO");

      // Desconecta observer
      if (mediaObserver) {
        console.log("[Album] Desconectando observer");
        mediaObserver.disconnect();
        mediaObserver = null;
      }

      // Pausa e limpa todos os v√≠deos
      document.querySelectorAll("#photos-carousel video, .album-slot video").forEach((video) => {
        video.pause();
        video.removeAttribute("src");
        video.load(); // For√ßa cancelar carregamento
      });

      // Cancela carregamento de todas as imagens
      document.querySelectorAll("#photos-carousel img, .album-slot img").forEach((img) => {
        const dataSrc = img.getAttribute("data-src");
        if (dataSrc) {
          console.log("[Album] Cancelando carregamento de imagem:", dataSrc);
          img.removeAttribute("data-src");
        }

        // Aborta carregamento em progresso
        if (img.src) {
          console.log("[Album] Abortando carregamento:", img.src);
          img.src = ""; // For√ßa cancelar requisi√ß√£o HTTP
          img.removeAttribute("src");
        }
      });

      console.log("[Album] ‚úÖ CLEANUP CONCLU√çDO");
    }

    // Expor cleanup globalmente (para ser chamado externamente)
    window.__albumCleanup = cleanupAlbum;

    /**
     * ========================================================================
     * HTMX: RE-INICIALIZA√á√ÉO AP√ìS SWAP
     * ========================================================================
     * 
     * QUANDO √â CHAMADO:
     * - Ap√≥s HTMX fazer swap de conte√∫do (navega√ß√£o entre p√°ginas)
     * 
     * O QUE FAZ:
     * - Se estiver na p√°gina /album, re-inicializa todas as funcionalidades
     * - Necess√°rio porque o HTML foi substitu√≠do (elementos novos)
     */
    document.addEventListener("htmx:afterSwap", (e) => {
      if (window.location.pathname.includes("/album")) {
        console.log("[Album] htmx:afterSwap detectado, reinicializando...");
        initDragDrop();
        initPhotoDelete();
        initLazyLoading();
      }
    });

    /**
     * ========================================================================
     * INICIALIZA√á√ÉO
     * ========================================================================
     * 
     * Executa apenas se estiver na p√°gina /album
     */
    if (window.location.pathname.includes("/album")) {
      console.log("[Album] Inicializa√ß√£o inicial na p√°gina /album");
      initDragDrop();
      initSlotRemoval();
      initPhotoDelete();
      initLazyLoading();
    } else {
      console.log("[Album] Script carregado mas n√£o est√° em /album, ignorando inicializa√ß√£o");
    }
  })();
</script>
